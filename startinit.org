:DONE: cosmetics.org, gnu-emacs-startup.org, gnu.org, learning-emacs.org, 
:TODO: 
* Save desktop mode

#+BEGIN_SRC emacs-lisp 

(desktop-save-mode 1)

#+END_SRC

* Org Agenda
#+BEGIN_SRC emacs-lisp 

(setq org-agenda-files (quote ("/home/trottar/ResearchNP/org_file/google_calendar/google_calendar.org")))

#+END_SRC
* Promt yes to y and no to n

#+BEGIN_SRC emacs-lisp 

(fset 'yes-or-no-p 'y-or-n-p)

#+END_SRC

* Add time stamp to files when saving

#+BEGIN_SRC emacs-lisp  

(add-hook 'before-save-hook 'time-stamp)
(setq time-stamp-pattern nil)

#+END_SRC

* Packages
#+BEGIN_SRC emacs-lisp
;; packages
(when (>= emacs-major-version 24)
  (require 'package)
  (package-initialize)
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
  )
#+END_SRC
* ????

#+BEGIN_SRC emacs-lisp  

(auto-insert-mode 1)

#+END_SRC

* Create template files for cpp, cc, C, py, sh, csh, org

#+BEGIN_SRC emacs-lisp  

(add-hook 'find-file-hook 'auto-insert)
(defun auto-insert ()
  (interactive)
  (when (and 
         (string-match "\\.\\([C]\\|cc\\|cpp\\)\\'" (buffer-file-name))
         (eq 1 (point-max)))
    (insert-file "~/.emacs.d/insert/template.C"))
    (when (and 
         (string-match "\\.py" (buffer-file-name))
         (eq 1 (point-max)))
      (insert-file "~/.emacs.d/insert/template.py"))
    (when (and 
	   (string-match "\\.\\(sh\\|csh\\)\\'" (buffer-file-name))
	   (eq 1 (point-max)))
      (insert-file "~/.emacs.d/insert/template.sh"))
    (when (and 
	   (string-match "\\.org\\'" (buffer-file-name))
	   (eq 1 (point-max)))
      (insert-file "~/.emacs.d/insert/template.org")))

#+END_SRC

* Backup saves

#+BEGIN_SRC emacs-lisp  

(setq  backup-directory-alist '(("." . "~/.backups"))
 backup-by-copying t
 version-control t
 delete-old-versions t
 kept-new-versions 20
 kept-old-versions 5)

#+END_SRC

* Allows easy commenting

#+BEGIN_SRC emacs-lisp  

(defun comment-or-uncomment-region-or-line ()
  "Comments or uncomments the region or the current line if there's no active region."
  (interactive)
  (let (beg end)
    (if (region-active-p)
	(setq beg (region-beginning) end (region-end))
      (setq beg (line-beginning-position) end (line-end-position)))
    (comment-or-uncomment-region beg end)))

(global-set-key "\M-;" 'comment-or-uncomment-region-or-line)

#+END_SRC

* Allows for org mode to distinguish coding languages... maybe ????

#+BEGIN_SRC emacs-lisp  

(org-babel-do-load-languages
   'org-babel-load-languages
   '((R . t)
     (org . t)
     (ditaa . t)
     (latex . t)
     (dot . t)
     (emacs-lisp . t)
     (gnuplot . t)
     (screen . nil)
     (shell . t)
     (sql . nil)
     (sqlite . t)))

#+END_SRC

* Set abbreviations for quick typing...not working ????

#+BEGIN_SRC emacs-lisp  

(setq abbrev-file-name "~/.emacs.d/abbrev_defs")
(setq-default abbrev-mode t)
(global-set-key [C-tab] 'abbrev-mode)

#+END_SRC

* Find word count...not working ???

#+BEGIN_SRC emacs-lisp  

;; Add the path to the repo
(add-to-list 'load-path "~/Programs/wc-mode/")
(require 'wc-mode)
(global-set-key "\C-cw" 'wc-mode)

#+END_SRC

* org-mode settings

#+BEGIN_SRC emacs-lisp 
(setq org-indent-mode t)
(setq org-indent-indentation-per-level 2)

#+END_SRC
* Clean UI


#+BEGIN_SRC emacs-lisp

(when window-system
  (setq frame-title-format '(buffer-file-name "%f" ("%b")))
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (blink-cursor-mode -1)
(scroll-bar-mode -1)



)


;; (tooltip-mode -1)
;; (tool-bar-mode -1)
#+END_SRC
* Don't highlight lines
#+BEGIN_SRC emacs-lisp
(add-hook 'org-mode-hook
          (lambda()
            (hl-line-mode -1)
            (global-hl-line-mode -1))
          't
          )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq prelude-whitespace nil)
#+END_SRC
* Wrap text:
#+BEGIN_SRC emacs-lisp
(global-visual-line-mode)
#+END_SRC
* Public key error
#+BEGIN_SRC emacs-lisp
(setq package-check-signature nil)
#+END_SRC
* Startup frame and cursor

#+BEGIN_SRC emacs-lisp
  ;; (toggle-maxframe)
  (require 'olivetti)
  (setq default-frame-alist
	'(
	  (width . 160) ; character
	  (height . 42) ; lines
  (cursor-color . "red") 
	  ))
  ;; (zenburn)
  ;; (monaco-font)
  ;; (minuscule-type)
  ;; (turn-on-olivetti-mode)

  (recenter-top-bottom)
  ;; (deja-vu-font)

#+END_SRC
* hunspell, for spellcheck

#+BEGIN_SRC emacs-lisp 

  (require 'flyspell)
  (flyspell-mode-on)

  ;; (defun add-word-to-personal-dictionary ()
  ;;   (interactive)
  ;;   (let ((current-location (point))
  ;;         (word (flyspell-get-word)))
  ;;     (when (consp word)
  ;;       (flyspell-do-correct 'save nil (car word) current-location (cadr word) (caddr word) current-location)))) 
  ;; find aspell and hunspell automatically


  ;; avoid spell-checking doublon (double word) in certain major modes
  (defvar flyspell-check-doublon t
    "Check doublon (double word) when calling `flyspell-highlight-incorrect-region'.")
   (make-variable-buffer-local 'flyspell-check-doublon)

  (eval-after-load 'flyspell
    '(progn
       ;; {{ flyspell setup for web-mode
       (defun web-mode-flyspell-verify ()
	 (let* ((f (get-text-property (- (point) 1) 'face))
		rlt)
	   (cond
	    ;; Check the words with these font faces, possibly.
	    ;; This *blacklist* will be tweaked in next condition
	    ((not (memq f '(web-mode-html-attr-value-face
			    web-mode-html-tag-face
			    web-mode-html-attr-name-face
			    web-mode-constant-face
			    web-mode-doctype-face
			    web-mode-keyword-face
			    web-mode-comment-face ;; focus on get html label right
			    web-mode-function-name-face
			    web-mode-variable-name-face
			    web-mode-css-property-name-face
			    web-mode-css-selector-face
			    web-mode-css-color-face
			    web-mode-type-face
			    web-mode-block-control-face)))
	     (setq rlt t))
	    ;; check attribute value under certain conditions
	    ((memq f '(web-mode-html-attr-value-face))
	     (save-excursion
	       (search-backward-regexp "=['\"]" (line-beginning-position) t)
	       (backward-char)
	       (setq rlt (string-match "^\\(value\\|class\\|ng[A-Za-z0-9-]*\\)$"
				       (thing-at-point 'symbol)))))
	    ;; finalize the blacklist
	    (t
	     (setq rlt nil)))
	   rlt))
       (put 'web-mode 'flyspell-mode-predicate 'web-mode-flyspell-verify)
       ;; }}

       ;; better performance
       (setq flyspell-issue-message-flag nil)

       ;; flyspell-lazy is outdated and conflicts with latest flyspell
       ;; It only improves the performance of flyspell so it's not essential.

       (defadvice flyspell-highlight-incorrect-region (around flyspell-highlight-incorrect-region-hack activate)
	 (if (or flyspell-check-doublon (not (eq 'doublon (ad-get-arg 2))))
	     ad-do-it))))


  ;; The logic is:
  ;; If (aspell installed) { use aspell}
  ;; else if (hunspell installed) { use hunspell }
  ;; English dictionary is used.
  ;;
  ;; I prefer aspell because:
  ;; 1. aspell is older
  ;; 2. looks Kevin Atkinson still get some road map for aspell:
  ;; @see http://lists.gnu.org/archive/html/aspell-announce/2011-09/msg00000.html
  (defun flyspell-detect-ispell-args (&optional run-together)
    "If RUN-TOGETHER is true, spell check the CamelCase words.
  Please note RUN-TOGETHER will make aspell less capable. So it should only be used in prog-mode-hook."
    (let* (args)
      (when ispell-program-name
	(cond
	 ;; use aspell
	 ((string-match "aspell$" ispell-program-name)
	  ;; force the English dictionary, support Camel Case spelling check (tested with aspell 0.6)
	  (setq args (list "--sug-mode=ultra" "--lang=en_US"))
	  ;; "--run-together-min" could not be 3, see `check` in "speller_impl.cpp".
	  ;; The algorithm is not precise.
	  ;; Run `echo tasteTableConfig | aspell --lang=en_US -C --run-together-limit=16  --encoding=utf-8 -a` in shell.
	  (when run-together
	    (cond
	     ;; Kevin Atkinson said now aspell supports camel case directly
	     ;; https://github.com/redguardtoo/emacs.d/issues/796
	     ((string-match-p "--camel-case"
			      (shell-command-to-string (concat ispell-program-name " --help")))
	      (setq args (append args '("--camel-case"))))

	     ;; old aspell uses "--run-together". Please note we are not dependent on this option
	     ;; to check camel case word. wucuo is the final solution. This aspell options is just
	     ;; some extra check to speed up the whole process.
	     (t
	      (setq args (append args '("--run-together" "--run-together-limit=16")))))))

	 ;; use hunsepll
	 ((string-match "hunspell$" ispell-program-name)
	  (setq args nil))))
      args))

  ;; Aspell Setup (recommended):
  ;; Skipped because it's easy.
  ;;
  ;; Hunspell Setup:
  ;; 1. Install hunspell from http://hunspell.sourceforge.net/
  ;; 2. Download openoffice dictionary extension from
  ;; http://extensions.openoffice.org/en/project/english-dictionaries-apache-openoffice
  ;; 3. That is download `dict-en.oxt'. Rename that to `dict-en.zip' and unzip
  ;; the contents to a temporary folder.
  ;; 4. Copy `en_US.dic' and `en_US.aff' files from there to a folder where you
  ;; save dictionary files; I saved it to `~/usr_local/share/hunspell/'
  ;; 5. Add that path to shell env variable `DICPATH':
  ;; setenv DICPATH $MYLOCAL/share/hunspell
  ;; 6. Restart emacs so that when hunspell is run by ispell/flyspell, that env
  ;; variable is effective.
  ;;
  ;; hunspell will search for a dictionary called `en_US' in the path specified by
  ;; `$DICPATH'

  (defvar force-to-use-hunspell nil
    "If t, force to use hunspell.  Or else, search aspell at first and fall
  back to hunspell if aspell is not found.")

  (cond
   ;; use aspell
   ((and (not force-to-use-hunspell) (executable-find "aspell"))
    (setq ispell-program-name "aspell"))

   ;; use hunspell
   ((executable-find "hunspell")
    (setq ispell-program-name "hunspell")
    (setq ispell-local-dictionary "en_US")
    (setq ispell-local-dictionary-alist
	  '(("en_US" "[[:alpha:]]" "[^[:alpha:]]" "[']" nil ("-d" "en_US") nil utf-8))))
   (t (setq ispell-program-name nil)
      (message "You need install either aspell or hunspell for ispell")))

  ;; `ispell-cmd-args' contains *extra* arguments appending to CLI process
  ;; when (ispell-send-string). Useless!
  ;; `ispell-extra-args' is *always* used when start CLI aspell process
  (setq-default ispell-extra-args (flyspell-detect-ispell-args t))
  ;; (setq ispell-cmd-args (flyspell-detect-ispell-args))
  (defadvice ispell-word (around my-ispell-word activate)
    (let* ((old-ispell-extra-args ispell-extra-args))
      (ispell-kill-ispell t)
      ;; use emacs original arguments
      (setq ispell-extra-args (flyspell-detect-ispell-args))
      ad-do-it
      ;; restore our own ispell arguments
      (setq ispell-extra-args old-ispell-extra-args)
      (ispell-kill-ispell t)))

  (defadvice flyspell-auto-correct-word (around my-flyspell-auto-correct-word activate)
    (let* ((old-ispell-extra-args ispell-extra-args))
      (ispell-kill-ispell t)
      ;; use emacs original arguments
      (setq ispell-extra-args (flyspell-detect-ispell-args))
      ad-do-it
      ;; restore our own ispell arguments
      (setq ispell-extra-args old-ispell-extra-args)
      (ispell-kill-ispell t)))

  (defun text-mode-hook-setup ()
    ;; Turn off RUN-TOGETHER option when spell check text-mode
    (setq-local ispell-extra-args (flyspell-detect-ispell-args)))
  (add-hook 'text-mode-hook 'text-mode-hook-setup)

  (defun enable-flyspell-mode-conditionally ()
    (when (and (not *no-memory*)
	       ispell-program-name
	       (executable-find ispell-program-name))
      ;; I don't use flyspell in text-mode because I often use Chinese.
      ;; I'd rather manually spell check the English text
      (flyspell-mode 1)))

  ;; You can also use "M-x ispell-word" or hotkey "M-$". It pop up a multiple choice
  ;; @see http://frequal.com/Perspectives/EmacsTip03-FlyspellAutoCorrectWord.html
  (global-set-key (kbd "C-c s") 'flyspell-auto-correct-word)

  (defun my-clean-aspell-dict ()
    "Clean ~/.aspell.pws (dictionary used by aspell)."
    (interactive)
    (let* ((dict (file-truename "~/.aspell.en.pws"))
	   (lines (read-lines dict))
	   ;; sort words
	   (aspell-words (sort (cdr lines) 'string<)))
      (with-temp-file dict
	(insert (format "%s %d\n%s"
			  "personal_ws-1.1 en"
			  (length aspell-words)
			  (mapconcat 'identity aspell-words "\n"))))))

  ;; {{ langtool setup
  (eval-after-load 'langtool
    '(progn
       (setq langtool-generic-check-predicate
	     '(lambda (start end)
		;; set up for `org-mode'
		(let* ((begin-regexp "^[ \t]*#\\+begin_\\(src\\|html\\|latex\\|example\\|quote\\)")
		       (end-regexp "^[ \t]*#\\+end_\\(src\\|html\\|latex\\|example\\|quote\\)")
		       (case-fold-search t)
		       (ignored-font-faces '(org-verbatim
					     org-block-begin-line
					     org-meta-line
					     org-tag
					     org-link
					     org-table
					     org-level-1
					     org-document-info))
		       (rlt t)
		       ff
		       th
		       b e)
		  (save-excursion
		    (goto-char start)

		    ;; get current font face
		    (setq ff (get-text-property start 'face))
		    (if (listp ff) (setq ff (car ff)))

		    ;; ignore certain errors by set rlt to nil
		    (cond
		     ((memq ff ignored-font-faces)
		      ;; check current font face
		      (setq rlt nil))
		     ((or (string-match "^ *- $" (buffer-substring (line-beginning-position) (+ start 2)))
			  (string-match "^ *- $" (buffer-substring (line-beginning-position) (+ end 2))))
		      ;; dash character of " - list item 1"
		      (setq rlt nil))

		     ((and (setq th (thing-at-point 'evil-WORD))
			   (or (string-match "^=[^=]*=[,.]?$" th)
			       (string-match "^\\[\\[" th)
			       (string-match "^=(" th)
			       (string-match ")=$" th)
			       (string= "w3m" th)))
		      ;; embedded cde like =w3m= or org-link [[http://google.com][google]] or [[www.google.com]]
		      ;; langtool could finish checking before major mode prepare font face for all texts
		      (setq rlt nil))
		     (t
		      ;; inside source block?
		      (setq b (re-search-backward begin-regexp nil t))
		      (if b (setq e (re-search-forward end-regexp nil t)))
		      (if (and b e (< start e)) (setq rlt nil)))))
		  ;; (if rlt (message "start=%s end=%s ff=%s" start end ff))
		  rlt)))))
  ;; }}

  (eval-after-load 'wucuo
    '(progn
       ;; do NOT turn on flyspell-mode automatically when running `wucuo-start'
       (setq wucuo-auto-turn-on-flyspell nil)))

  (provide 'init-spelling)
#+END_SRC

** References:
[[http://emacswiki.org/emacs/InteractiveSpell#toc2][EmacsWiki: Interactive Spell]]
[[https://lists.gnu.org/archive/html/help-gnu-emacs/2015-03/msg00153.html][Getting flyspell + hunspell to work on OS X 10.10]]
[[https://joelkuiper.eu/spellcheck_emacs][Spell checking in Emacs]]
[[http://stackoverflow.com/questions/25415070/hunspell-emacs-on-os-x-10-9][hunspell / emacs on OS X 10.9 - Stack Overflow]]
[[http://stackoverflow.com/questions/3961119/working-setup-for-hunspell-in-emacs][Working setup for hunspell in Emacs - Stack Overflow]]
[[http://unix.stackexchange.com/questions/86554/make-hunspell-work-with-emacs-and-german-language][spell checking - Make hunspell work with emacs and german language - Unix & Linux Stack Exchange]]
[[http://blog.binchen.org/posts/what-s-the-best-spell-check-set-up-in-emacs.html][What's the best spell check setup in emacs | Chen's blog]]
[[http://www.lonecpluspluscoder.com/2015/03/setting-up-emacs-spell-checking-on-os-x/][Setting up Emacs spell checking on OS X - The Lone C++ Coder's Blog]]
* langtool, grammar check
#+BEGIN_SRC emacs-lisp 
(eval-when-compile
  (require 'cl))

(require 'flymake)

(defgroup langtool nil
  "Customize langtool"
  :group 'applications)

(defvar current-prefix-arg)
(defvar unread-command-events)
(defvar locale-language-names)

(defcustom langtool-java-bin "java"
  "*Executing java command."
  :group 'langtool
  :type 'file)

(defcustom langtool-language-tool-jar nil
  "*LanguageTool jar file."
  :group 'langtool
  :type 'file)

(defcustom langtool-default-language "en"
  "*Language name pass to LanguageTool."
  :group 'langtool
  :type 'string)

(defcustom langtool-disabled-rules nil
  "*Disabled rules pass to LanguageTool.
String that separated by comma or list of string.
"
  :group 'langtool
  :type '(choice 
          (list string)
          string))

(defvar langtool-temp-file nil)
(make-variable-buffer-local 'langtool-temp-file)

(defconst langtool-output-regexp 
  (concat
   "^[0-9]+\\.) Line \\([0-9]+\\), column \\([0-9]+\\), Rule ID: \\(.*\\)\n"
   "Message: \\(.*\\)\n"
   "Suggestion: \\(\\(?:.*\\)\n\\(?:.*\\)\n\\(?:.*\\)\\)\n"
    "\n?"
   ))

(defvar langtool-buffer-process nil)
(make-variable-buffer-local 'langtool-buffer-process)

(defvar langtool-mode-line-process 
  '(langtool-buffer-process " LanguageTool running..."))

(defun langtool-goto-next-error ()
  "Goto next error."
  (interactive)
  (let ((overlays (langtool-overlays-region (point) (point-max))))
    (langtool-goto-error 
     overlays
     (lambda (ov) (< (point) (overlay-start ov))))))

(defun langtool-goto-previous-error ()
  "Goto previous error."
  (interactive)
  (let ((overlays (langtool-overlays-region (point-min) (point))))
    (langtool-goto-error 
     (reverse overlays)
     (lambda (ov) (< (overlay-end ov) (point))))))

(defun langtool-show-message-at-point ()
  "Show error details at point"
  (interactive)
  (let ((msgs (langtool-current-error-messages)))
    (if (null msgs)
        (message "No errors")
      (let ((buf (get-buffer-create langtool-error-buffer-name)))
        (with-current-buffer buf
          (erase-buffer)
          (mapc
           (lambda (msg) (insert msg "\n"))
           msgs))
        (save-window-excursion
          (display-buffer buf)
          (let* ((echo-keystrokes)
                 (event (read-event)))
            (setq unread-command-events (list event))))))))

(defun langtool-check-done ()
  "Finish LanguageTool process and cleanup existing overlays."
  (interactive)
  (when langtool-buffer-process
    (delete-process langtool-buffer-process))
  (langtool-clear-buffer-overlays)
  (message "Cleaned up LanguageTool."))

(defun langtool-check-buffer (&optional lang)
  "Check context current buffer.
Optional \\[universal-argument] read LANG name."
  (interactive
   (when current-prefix-arg
     (list (langtool-read-lang-name))))
  (langtool-check-command)
  (add-to-list 'mode-line-process langtool-mode-line-process)
  (let ((file (buffer-file-name)))
    (unless langtool-temp-file
      (setq langtool-temp-file (make-temp-file "langtool-")))
    (when (or (null file) (buffer-modified-p))
      (save-restriction
        (widen)
        (let ((coding-system-for-write buffer-file-coding-system))
          (write-region (point-min) (point-max) langtool-temp-file nil 'no-msg))
        (setq file langtool-temp-file)))
    (langtool-clear-buffer-overlays)
    (let ((command langtool-java-bin)
          args)
      (setq args (list "-jar" (expand-file-name langtool-language-tool-jar)
                       "-c" (langtool-java-coding-system buffer-file-coding-system)
                       "-l" (or lang langtool-default-language)
                       "-d" (langtool-disabled-rules)
                       file))
      (let* ((buffer (langtool-process-create-buffer))
             (proc (apply 'start-process "LanguageTool" buffer command args)))
        (set-process-filter proc 'langtool-process-filter)
        (set-process-sentinel proc 'langtool-process-sentinel)
        (process-put proc 'langtool-source-buffer (current-buffer))
        (setq langtool-buffer-process proc)))))

(defun langtool-goto-error (overlays predicate)
  (catch 'done
    (mapc
     (lambda (ov)
       (when (funcall predicate ov)
         (goto-char (overlay-start ov))
         (throw 'done t)))
     overlays)
    nil))

(defun langtool-read-lang-name ()
  (completing-read "Lang: " locale-language-names))

(defun langtool-create-overlay (line column message)
  (save-excursion
    (goto-char (point-min))
    (condition-case nil
        (progn
          (forward-line (1- line))
          (let ((start (line-beginning-position))
                (end (line-end-position)))
            (move-to-column column)
            (backward-word)
            ;;FIXME LanguageTool column sometimes wrong!
            ;; restrict to current line
            (setq start (min end (max start (point))))
            (forward-word 2)
            (setq end (min end (point)))
            (let ((ov (make-overlay start end)))
              (overlay-put ov 'langtool-message message)
              (overlay-put ov 'priority 1)
              (overlay-put ov 'face 'flymake-errline))))
      ;;TODO ignore?
      (end-of-buffer nil))))

(defvar langtool-error-buffer-name " *LanguageTool Errors* ")
(defun langtool-current-error-messages ()
  (remove nil
          (mapcar
           (lambda (ov)
             (overlay-get ov 'langtool-message))
           (overlays-at (point)))))

(defun langtool-clear-buffer-overlays ()
  (mapc
   (lambda (ov)
     (delete-overlay ov))
   (langtool-overlays-region (point-min) (point-max))))

(defun langtool-overlays-region (start end)
  (sort
   (remove
    nil
    (mapcar
     (lambda (ov)
       (when (overlay-get ov 'langtool-message)
         ov))
     (overlays-in start end)))
   (lambda (ov1 ov2)
     (< (overlay-start ov1) (overlay-start ov2)))))

(defun langtool-check-command ()
  (when (or (null langtool-java-bin)
            (not (executable-find langtool-java-bin)))
    (error "java command is not found"))
  (when (or (null langtool-language-tool-jar)
            (not (file-readable-p langtool-language-tool-jar)))
    (error "langtool jar file is not found"))
  (when langtool-buffer-process
    (error "Another process is running")))

(defun langtool-disabled-rules ()
  (cond
   ((stringp langtool-disabled-rules)
    langtool-disabled-rules)
   ((consp langtool-disabled-rules)
    (mapconcat 'identity langtool-disabled-rules ","))
   (t
    "")))

(defun langtool-process-create-buffer ()
  (generate-new-buffer " *LanguageTool* "))

(defun langtool-process-filter (proc event)
  (with-current-buffer (process-buffer proc)
    (goto-char (point-max))
    (insert event)
    (let ((min (or (process-get proc 'langtool-process-done)
                   (point-min)))
          (buffer (process-get proc 'langtool-source-buffer))
          messages)
      (goto-char min)
      (while (re-search-forward langtool-output-regexp nil t)
        (let ((line (string-to-number (match-string 1)))
              (column (string-to-number (match-string 2)))
              (message
               (concat (match-string 3) "\n" 
                       (match-string 4) (match-string 5))))
          (setq messages (cons
                          (list line column message)
                          messages))))
      (process-put proc 'langtool-process-done (point))
      (when (buffer-live-p buffer)
        (with-current-buffer buffer
          (mapc
           (lambda (msg)
             (let ((line (nth 0 msg))
                   (col (nth 1 msg))
                   (message (nth 2 msg)))
               (langtool-create-overlay line col message)))
           messages))))))

(defun langtool-process-sentinel (proc event)
  (when (memq (process-status proc) '(exit signal))
    (let ((source (process-get proc 'langtool-source-buffer)))
      (when (buffer-live-p source)
        (with-current-buffer source
          (setq langtool-buffer-process nil))))
    (unless (= (process-exit-status proc) 0)
      (message "LanguageTool finished with code %d" 
               (process-exit-status proc)))
    (let ((buffer (process-buffer proc)))
      (when (buffer-live-p buffer)
        (kill-buffer buffer)))))

;;TODO
(defun langtool-java-coding-system (coding-system)
  (let ((cs (coding-system-base coding-system)))
    (case cs
      (utf-8 "utf-8")
      (euc-jp "euc-jp")
      (shift_jis "sjis")
      (iso-2022-7bit "iso2022jp")
      (t "ascii"))))

(provide 'langtool)
#+END_SRC
* Guide key ... NOT WORKING
I think this is something similar ([[https://github.com/kai2nenobu/guide-key][source]]):
#+BEGIN_SRC emacs-lisp
  ;; (require 'guide-key)
  ;; (setq guide-key/guide-key-sequence '("s-m" "C-x 4"))
  ;; (guide-key-mode 1)  ; Enable guide-key-mode
  ;; (setq guide-key/guide-key-sequence '("C-x"))
  ;; (setq guide-key/recursive-key-sequence-flag t)

  ;; (defun guide-key/my-hook-function-for-org-mode ()
  ;;   (guide-key/add-local-guide-key-sequence "C-c")
  ;;   (guide-key/add-local-guide-key-sequence "C-c C-x")
  ;;   (guide-key/add-local-highlight-command-regexp "org-"))
  ;; (add-hook 'org-mode-hook 'guide-key/my-hook-function-for-org-mode)
#+END_SRC
* Distraction-free editing... NOT WORKING
#+BEGIN_SRC emacs-lisp
  ;; (require 'org-serenity-mode)
  ;; (defun serenity-mode ()
  ;;  "serenity"
  ;;  (interactive)
  ;;  (setq org-bullets-bullet-list (quote ("  ")))
  ;;  (org-serenity-mode)  
  ;;  (org-bullets-mode)
  ;; )
#+END_SRC
* Handle Emacs UTF-8 input

#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(setenv "LANG" "en_US.UTF-8")
#+END_SRC

* Sticky windows

#+BEGIN_SRC emacs-lisp
(global-set-key [(control x) (?0)] 'delete-other-windows)
(global-set-key [(control x) (?9)] 'sticky-window-keep-window-visible)
(global-set-key  (kbd "s-0") 'delete-window)
(global-set-key  (kbd "s-1") 'delete-other-windows)
(global-set-key  (kbd "s-9") 'sticky-window-keep-window-visible)
(global-set-key  (kbd "s-2") 'split-window-vertically)
(global-set-key  (kbd "s-3") 'split-window-horizontally)
#+END_SRC

* abbreviations...???
Automatically load abbreviations table:
#+BEGIN_SRC emacs-lisp
(setq-default abbrev-mode t)
(read-abbrev-file "~/.emacs.d/.abbrev_defs")
(setq abbrev-file-name "~/.emacs.d/.abbrev_defs")

(setq save-abbrevs t)
(setq save-abbrevs 'silently)
(setq only-global-abbrevs t)
#+END_SRC
* reflash-indentation
#+BEGIN_SRC emacs-lisp
(defun reflash-indentation ()
"Fix spacing on the screen."
  (interactive)
  (org-indent-mode 1)
(recenter-top-bottom)
  )
#+END_SRC
* org predicates

  #+BEGIN_SRC emacs-lisp
(require 'org-element) 

  (defun org-checkbox-p ()
  "Predicate: Checks whether the current line org-checkbox"
    (and
;; (org-or-orgalist-p)
      (string-match "^\s*\\([-+*]\\|[0-9]+[.\\)]\\)\s\\[.?\\]\s" (or (thing-at-point 'line) ""))))

  (defun org-plain-text-list-p ()
  "Predicate: Checks whether the current line org-plain-text-list"
    (and
;; (org-or-orgalist-p)
      (string-match "^\s*\\([-+]\\|\s[*]\\|[0-9]+[.\\)]\\)\s" (or (thing-at-point 'line) ""))))
  #+END_SRC
* org-mode hooks

  #+BEGIN_SRC emacs-lisp

(setq org-hierarchical-todo-statistics nil)
  #+END_SRC
* org-todo
  #+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
  '((sequence "TODO(t)" "|" "DONE(d)")
  (sequence "TODO(t)" "CURRENT(c)" "|" "DONE(d)")))
  #+END_SRC
* fullscreen settings

[[http://amitp.blogspot.ca/2008/05/emacs-full-screen-on-mac-os-x.html][(Source)]]

#+BEGIN_SRC emacs-lisp
(defvar maxframe-maximized-p nil "maxframe is in fullscreen mode")

(defun toggle-maxframe ()
  "Toggle maximized frame"
  (interactive)
  (setq maxframe-maximized-p (not maxframe-maximized-p))
  (cond (maxframe-maximized-p (maximize-frame))
        (t (restore-frame))))

(define-key global-map [(s-return)] 'toggle-maxframe)
;; make it easy to go fullscreen
(defun toggle-fullscreen ()
  "Toggle full screen"
  (interactive)
  (set-frame-parameter
   nil 'fullscreen
   (when (not (frame-parameter nil 'fullscreen)) 'fullboth)))

;; and the keybinding
(unless (fboundp 'toggle-frame-fullscreen)
  (global-set-key (kbd "<f11>") 'toggle-fullscreen))
(unless (fboundp 'toggle-frame-fullscreen)
  (global-set-key (kbd "<f17>") 'toggle-fullscreen))

  (global-set-key (kbd "<f17>") 'toggle-fullscreen)

#+END_SRC
* directory settings

There is probably a lot of redundancy here, I don't understand this stuff too
well.

#+BEGIN_SRC emacs-lisp

;; (require 'dired-details+)



;; (defadvice dired-readin
;;     (after dired-after-updating-hook first () activate)
;;   "Sort dired listings with directories first before adding marks."
;;   (mydired-sort)
;;   (let ((dired-details-internal-overlay-list  ())) (dired-details-hide)))

(defcustom dired-details-hidden-string ""
  "*This string will be shown in place of file details and symbolic links."
  :group 'dired-details
  :type 'string)

(defcustom dired-details-initially-hide t
  "*Hide dired details on entry to dired buffers."
  :group 'dired-details
  :type 'boolean)
#+END_SRC

* scrollbar function

Manually remove the scrollbar if default setting fails when creating a new frame:

#+BEGIN_SRC emacs-lisp
(defun scrollbar-init ()
  (interactive)
  (scroll-bar-mode -1)
  )

(defun scrollbar-mode-turn-off-scrollbar ()
  (interactive)
  (scroll-bar-mode -1)
  )

(defun scrollbar-mode-turn-on-scrollbar ()
  (interactive)
  (scroll-bar-mode 1)
  )
#+END_SRC

* Emacs crashes, ERROR
Forgot what this does, I think it's in case Emacs crashes maybe to recover
autosaves?
#+BEGIN_SRC emacs-lisp
  ;; (defadvice recover-session (around disable-dired-omit-for-recover activate)
  ;;   (let ((dired-mode-hook dired-mode-hook))
  ;;     (remove-hook 'dired-mode-hook 'enable-dired-omit-mode)
  ;;     ad-do-it))
#+END_SRC
* Create custom keybinding prefix

#+BEGIN_QUOTE
I have an unconventional approach to this that I recommend highly. I have redefined the C-l ('ell') key to be a prefix key, and I use that to prefix my favorite commands. This key is very easy to type and it is bound to a function ('recenter) that isn't used that much. Well, I don't use 'recenter much, but even if you did, it can be assigned to C-l C-l which is almost as easy to type, and a small price to pay for the possibilities opened up by the Ctrl-L-map. (Actually I prefer 'redraw-display to 'recenter, so I gave that the place of honor.)
#+END_QUOTE
Source: [[http://stackoverflow.com/questions/5682631/what-are-good-custom-keybindings-in-emacs/5682737#5682737][ LenW's answer on keyboard - What are good custom keybindings in emacs? - Stack Overflow]]

Use ⌘-m as prefix for my own custom keybindings:
#+BEGIN_SRC emacs-lisp
(global-unset-key (kbd "s-j"))
(defvar s-j-map (make-keymap)
  "Keymap for local bindings and functions, prefixed by (Command-M)")
(define-key global-map (kbd "s-j") 's-j-prefix)
(fset 's-j-prefix s-j-map)
#+END_SRC
* Custom keybindings...Need to customize
Eventually replace these with this? https://github.com/noctuid/general.el



# #+BEGIN_SRC emacs-lisp
# ;; create a custom minor mode to override other keybindings and use mine instead
# (defvar key-minor-mode-map (make-keymap) "key-minor-mode keymap.")
# (define-minor-mode key-minor-mode
#   "A minor mode so that my key settings override annoying major modes."
#   t " key" 'key-minor-mode-map)
# (key-minor-mode 1)
# (defun my-minibuffer-setup-hook ()
#   (key-minor-mode 0))
# (add-hook 'minibuffer-setup-hook 'my-minibuffer-setup-hook)

# ;; unbind some existing keybindings
# ;; (define-key undo-tree-map (kbd "C-x r") nil)

# ;; and the keybindings
# ;; mk - mykeybindings

# (define-key key-minor-mode-map (kbd "s-j r t") 'org-render-table-at-point)

# (define-key key-minor-mode-map (kbd "s-j m c") 'multiple-cursors-reflash)

# (define-key key-minor-mode-map (kbd "s-J") 'dired-jump)

# (define-key key-minor-mode-map (kbd "s-j n s") 'yas/new-snippet)
# (define-key key-minor-mode-map (kbd "s-j y n") 'yas/new-snippet)

# (define-key help-mode-map (kbd "C-s-]") 'help-go-back)
# (define-key key-minor-mode-map (kbd "C-s-]") 'help-go-forward)


# (define-key key-minor-mode-map (kbd "s-j c m") 'css-mode)
# ;; (define-key css-mode-map (kbd "s-j c s") 'css-mode)
# (define-key key-minor-mode-map (kbd "s-j s h") 'sh-mode)
# (define-key key-minor-mode-map (kbd "s-j s m") 'sh-mode)

# (define-key key-minor-mode-map (kbd "s-k") 'kill-buffer)

# (define-key key-minor-mode-map (kbd "s-i") 'avy-goto-char)
# (define-key key-minor-mode-map (kbd "s-p") 'org-html-export-to-html-and-open)


# (define-key key-minor-mode-map (kbd "M-y") 'helm-show-kill-ring)

# (define-key key-minor-mode-map (kbd "M-h M-k") 'describe-key)

# (define-key key-minor-mode-map (kbd "s-M") 'visit-messages-buffer)

# (defun visit-messages-buffer ()
# (interactive)
# ()
#   (interactive)
#   (view-echo-area-messages)
# (other-window 1)
# )


# ;; (define-key key-minor-mode-map (kbd "s-p") 'move-region-to-other-window)

# (defun visit-messages-buffer-full-screen ()
#   (interactive)
#   (with-current-buffer (messages-buffer)
#   (goto-char (point-max))
#   (switch-to-buffer (current-buffer)))
#   )

# (define-key key-minor-mode-map (kbd "<s-backspace>") 'kill-region)

# (define-key key-minor-mode-map (kbd "s-j t c") 'org-table-create)

# (define-key key-minor-mode-map (kbd "C-;") 'org-def)
# (require 'flyspell)
# (define-key flyspell-mode-map (kbd "C-;") 'org-def)

# (define-key key-minor-mode-map (kbd "s-j u p") 'unfill-paragraph)

# (define-key key-minor-mode-map (kbd "C-w") 'copy-region-as-kill)

# ;; (define-key key-minor-mode-map (kbd "=") 'insert-equals-sign)

# (define-key key-minor-mode-map (kbd "s-j w s") 'isearch-forward-word)

# (define-key key-minor-mode-map (kbd "s-f") 'isearch-forward-ignore-case)

# (define-key key-minor-mode-map (kbd "s-j w m") 'whitespace-mode)

# (define-key key-minor-mode-map (kbd "s-j h l") 'spacemacs/toggle-highlight-current-line-globally-off)

# (define-key key-minor-mode-map (kbd "s-j r b") 'revert-buffer)

# (define-key key-minor-mode-map (kbd "s-j s b") 'scrollbar-mode-turn-off-scrollbar)

# (define-key key-minor-mode-map (kbd "s-j i l") 'imenu-list)
# (define-key key-minor-mode-map (kbd "s-j i m") 'imenu-list)

# (define-key key-minor-mode-map (kbd "s-j g t") 'google-translate-at-point)

# (define-key key-minor-mode-map (kbd "M-?") 'insert-question-mark)


# (define-key key-minor-mode-map (kbd "<s-S-down>") 'scratch)


# (define-key key-minor-mode-map (kbd "s-j g a") 'adobe-garamond-pro)
# (define-key key-minor-mode-map (kbd "s-j ag") 'adobe-garamond-pro)
# (define-key key-minor-mode-map (kbd "s-j gf") 'adobe-garamond-pro)
# (define-key key-minor-mode-map (kbd "s-j mf") 'monaco-font)
# (define-key key-minor-mode-map (kbd "s-j mo") 'monaco-font)

# (define-key key-minor-mode-map (kbd "s-j t t") 'toggle-between-src-and-example-block)

# ;; working with an external monitor
# (define-key key-minor-mode-map (kbd "s-n") 'make-frame)
# (define-key key-minor-mode-map (kbd "s-~") 'other-frame)
# (define-key key-minor-mode-map (kbd "s-`") 'other-window)

# (define-key key-minor-mode-map (kbd "C-x C-d") 'dired)

# (define-key key-minor-mode-map (kbd "s-j c p") 'path-copy-path-to-kill-ring)


# (define-key org-mode-map (kbd "s-j c s") 'org-clone-subtree)
# (define-key key-minor-mode-map (kbd "s-j p s") 'org-paste-subtree)
# (define-key key-minor-mode-map (kbd "s-j v") 'org-paste-subtree)
# (define-key key-minor-mode-map (kbd "s-j x") 'org-cut-subtree)
# (define-key key-minor-mode-map (kbd "s->") 'org-mark-subtree)


# (define-key key-minor-mode-map (kbd "M-'") 'insert-one-double-quote)
# (define-key key-minor-mode-map (kbd "M-s-.") 'mark-paragraph)

# (define-key key-minor-mode-map (kbd "M-_") 'em-dash)

# (define-key key-minor-mode-map (kbd "s-/") 'rgrep)

# (define-key key-minor-mode-map (kbd "C-v") 'kdm/html2org-clipboard)


# (define-key key-minor-mode-map (kbd "s-r") 'counsel-recentf)

# (define-key key-minor-mode-map (kbd "M-.") 'insert-period)
# (define-key key-minor-mode-map (kbd "M-,") 'insert-comma)


# (define-key key-minor-mode-map (kbd "s-j g b") 'gist-buffer-to-pasteboard)

# ;; (define-key key-minor-mode-map (kbd "<M-s-up>") 'scroll-down-command)
# ;; (define-key key-minor-mode-map (kbd "<M-s-down>") 'scroll-up-command)


# (define-key key-minor-mode-map (kbd "M-s b") 'book-search)
# (define-key key-minor-mode-map (kbd "M-s c") 'current-buffers-search)


# (define-key key-minor-mode-map (kbd "s-;") 'helm-resume)
# (define-key key-minor-mode-map (kbd "s-j o m") 'org-mode)
# (define-key key-minor-mode-map (kbd "s-j f m") 'fundamental-mode)
# (define-key key-minor-mode-map (kbd "s-j e l") 'emacs-lisp-mode)


# (define-key key-minor-mode-map (kbd "s-j w c") 'wc-mode)
# (define-key key-minor-mode-map (kbd "s-j o c") 'org-wc-count-subtrees)
# (define-key key-minor-mode-map (kbd "s-j o c") 'org-wc-display)

# (global-set-key (kbd "C-c m") 'compose-mail)
# ;; (global-set-key (kbd "C-c m") 'yale-or-vivovii-compose)


# (define-key key-minor-mode-map (kbd "s-j m b") 'menu-bar-mode)

# (define-key key-minor-mode-map (kbd "s-m") 'mc/mark-all-like-this-dwim)

# (define-key key-minor-mode-map (kbd "s-j d c") 'org-table-delete-column)
# (define-key key-minor-mode-map (kbd "s-j i c") 'org-table-insert-column)
# (define-key key-minor-mode-map (kbd "s-j i r") 'org-table-insert-row)


# ;; mu4e-gmail
# ;; (define-key key-minor-mode-map (kbd "s-L") 'mu4e-gmail)
# (define-key key-minor-mode-map (kbd "]gi") 'mu4e-gmail)
# (define-key key-minor-mode-map (kbd "]gm") 'mu4e-gmail)



# ;; don't know why this stopped working
# (define-key key-minor-mode-map (kbd "C-c C-x <C-i>") 'org-clock-in)
# (define-key key-minor-mode-map (kbd "C-c C-x <C-i>") 'org-clock-in)


# (define-key key-minor-mode-map (kbd "M-s-=") 'calc-eval-region)

# (define-key key-minor-mode-map (kbd "s-j p m") 'poetry-mode)

# ;; (define-key key-minor-mode-map (kbd "s-p") 'zin/org-checkbox-next)

# (define-key key-minor-mode-map (kbd "<f20>") 'pomodoro-start-jay)
# (define-key key-minor-mode-map (kbd "s-j p o") 'pomodoro-start-jay)



# (define-key key-minor-mode-map (kbd "<C-s-left>") 'work-on-book)



# (define-key key-minor-mode-map (kbd "s-j t d") 'jd-org-today)
# (define-key key-minor-mode-map (kbd "s-j c i") 'jd-clock-in)



# (define-key key-minor-mode-map (kbd "s-.") 'org-select-line)
# (define-key key-minor-mode-map (kbd "C-.") 'searchlink)


# ;; (define-key key-minor-mode-map (kbd "s-p") 'jay-refile-region)

# (define-key key-minor-mode-map (kbd "M-0") 'move-region-to-other-window)

# (define-key key-minor-mode-map (kbd "s-b") 'narrow-or-widen-dwim)
#                                         ; org-narrow-to-subtree

# (define-key key-minor-mode-map (kbd "s-B") 'helm-mini)


# (define-key key-minor-mode-map (kbd "C-x <return> RET") 'mc/mark-all-dwim)

# (define-key key-minor-mode-map (kbd "s-H") 'hyperbole)

# (define-key key-minor-mode-map (kbd "M-e") 'smart-forward-sentence)

# (define-key key-minor-mode-map (kbd "M-q") 'prelude-switch-to-previous-buffer)

# (define-key key-minor-mode-map (kbd "s-]") 'org-forward-heading-same-level)
# (define-key key-minor-mode-map (kbd "s-[") 'org-backward-heading-same-level)


# (define-key key-minor-mode-map (kbd "C-M-]") 'org-next-subtree-and-narrow)
# (define-key key-minor-mode-map (kbd "C-M-[") 'org-previous-subtree-and-narrow)

# (define-key key-minor-mode-map (kbd "C-]") 'org-next-subtree-same-level-and-narrow)

# (define-key key-minor-mode-map (kbd "ESC ESC") 'org-previous-subtree-same-level-and-narrow)


# (define-key key-minor-mode-map (kbd "s-F") 'pasteboard-search-for-clipboard-contents)

# (define-key key-minor-mode-map (kbd "M-\"") 'open-abbrevs)

# (define-key key-minor-mode-map (kbd "s-|") 'path-copy-path-to-clipboard)

# (define-key key-minor-mode-map (kbd "<s-return>") 'toggle-fullscreen)

# ;; (define-key key-minor-mode-map (kbd "s-v") 'pasteboard-paste-without-smart-quotes)
# ;; (define-key orgalist-mode-map (kbd "s-v") 'pasteboard-paste-without-smart-quotes)
# (global-set-key (kbd "s-v") 'pasteboard-paste-no-spaces)
# (define-key org-mode-map (kbd "s-v") 'pasteboard-paste-spaces-maybe)
# ;; (define-key orgalist-mode-map (kbd "s-v") 'pasteboard-paste-spaces-maybe)
# ;; (define-key fundamental-mode-map (kbd "s-v") 'pasteboard-paste-without-smart-quotes)
# (define-key text-mode-map (kbd "s-v") 'pasteboard-paste-without-smart-quotes)
# ;; (define-key markdown-mode-map (kbd "s-v") 'pasteboard-paste-without-smart-quotes)

# ;; (define-key sh-mode-map (kbd "s-v") 'pasteboard-paste-no-spaces)
# (define-key emacs-lisp-mode-map (kbd "s-v") 'pasteboard-paste-no-spaces)
# (define-key key-minor-mode-map (kbd "C-s-v") 'kdm/html2org-clipboard)
# (define-key key-minor-mode-map (kbd "C-s-c") 'ox-clip-formatted-copy)
# (define-key key-minor-mode-map (kbd "M-v") 'kdm/html2org-clipboard)


# (define-key key-minor-mode-map (kbd "s-x") 'pasteboard-cut-and-capitalize)
# (define-key key-minor-mode-map (kbd "s-c") 'pasteboard-copy)
# (define-key key-minor-mode-map (kbd "s-V") 'pasteboard-paste-no-spaces)


# (define-key emacs-lisp-mode-map (kbd "s-v") 'pasteboard-paste-no-spaces)
# ;; (define-key rebuilder-mode-map (kbd "s-v") 'pasteboard-paste-no-spaces)


# (define-key key-minor-mode-map (kbd "s-h") 'replace-string)

# (global-unset-key (kbd "C-S-r"))
# (define-key key-minor-mode-map (kbd "C-S-r") nil)
# (define-key org-mode-map (kbd "C-S-r") nil)

# (define-key key-minor-mode-map (kbd "M-s-g") 'gnugol-word-at-point)
# (define-key key-minor-mode-map (kbd "M-s-d") 'define-word-at-point)


# (define-key key-minor-mode-map (kbd "C-s-o") 'dired-jump)

# ;; (define-key org-mode-map (kbd "s-O") 'uo-byword-file)


# (define-key org-mode-map (kbd "s-O") 'reveal-in-finder)


# ;; pop mark
# (define-key key-minor-mode-map (kbd "C-x p")'pop-to-mark-command)

# ;; projectile
# ;; (define-key key-minor-mode-map (kbd "s-P") 'projectile-commander)

# (define-key key-minor-mode-map (kbd "s-E") 'new-email-from-subtree-no-signature)

# ;; and make it work in the minibuffer too
# (define-key minibuffer-local-map (kbd "s-v") 'pasteboard-paste-no-spaces)
# (define-key minibuffer-local-map (kbd "s-x") 'pasteboard-cut)
# (define-key minibuffer-local-map (kbd "s-c") 'copy-minibuffer-contents)
# (define-key minibuffer-local-map (kbd "s-a") 'copy-minibuffer-contents)

# (defun copy-minibuffer-contents (arg)
#   (interactive "p")
#   (beginning-of-visual-line)
#   (end-of-buffer)
#   (copy-region-as-kill (mark) (point))
#   (push-kill-ring-pasteboard-to-clipboard)
#   )




# (define-key key-minor-mode-map (kbd "C-c C-v") 'refile-region)

# ;; (define-key key-minor-mode-map (kbd "s-0") 'widen)

# (define-key key-minor-mode-map (kbd "s-0") 'copy-region-to-other-window)

# (define-key emacs-lisp-mode-map (kbd "C-c e") 'eval-buffer)
# (define-key org-mode-map (kbd "C-c e") 'eval-subtree)

# (define-key key-minor-mode-map (kbd "C-c r") 'eval-region)


# (define-key key-minor-mode-map (kbd "C-9") 'goto-last-change-reverse) ; super useful when editing
# (define-key key-minor-mode-map (kbd "C--") 'goto-last-change) ; super useful when editing

# ;; (define-key key-minor-mode-map (kbd "s-=") 'zoom-in-and-disable-menu-bar-mode)

# (define-key key-minor-mode-map (kbd "M-=") 'er/expand-region)
# (define-key key-minor-mode-map (kbd "C-=") 'er/expand-region)
# ;; (define-key key-minor-mode-map (kbd "C-8") 'embolden-or-bold)
# ;; replaced it with multiple-cursors-hydra/body for now

# ;; (define-key key-minor-mode-map (kbd "C-8") '(lambda (arg) (interactive "p") (wrap-region-trigger arg "*"))) ; wow this was a stroke of genius

# (define-key key-minor-mode-map (kbd "s-j r e") 'set-rectangular-region-anchor)

# (define-key key-minor-mode-map (kbd "C-d") 'kill-word-correctly-and-capitalize)
# ;; (define-key key-minor-mode-map (kbd "m-d") 'kill-word-correctly-and-capitalize)

# ;; (define-key key-minor-mode-map (kbd "m-D") 'org-shiftleft)



# (define-key key-minor-mode-map (kbd "C-l") 'reflash-indentation)
# ;; (define-key org-mode-map (kbd "C-l") 'reflash-indentation)


# (define-key key-minor-mode-map (kbd "=") 'smex) ; call any function with easiest keystroke possible
# ;; (define-key key-minor-mode-map (kbd "=") 'counsel-M-x) ; call any function with easiest keystroke possible
# (define-key key-minor-mode-map (kbd "M-x") 'helm-M-x) ; call helm-M-x instead of regular M-x
# ;; (define-key key-minor-mode-map (kbd "\|") 'deft)

# (define-key org-mode-map (kbd "M-K") 'kill-clause)
# (define-key emacs-lisp-mode-map (kbd "M-K") 'kill-sexp)

# (define-key key-minor-mode-map (kbd "C-M-8") 'org-toggle-heading) ; i.e. subheading


# (define-key key-minor-mode-map (kbd "M-8") 'org-toggle-heading-same-level)
# (define-key key-minor-mode-map (kbd "M-*") 'org-toggle-todo-heading)
# ;; (define-key key-minor-mode-map (kbd "C-M-*") 'org-toggle-todo-subheading)


# (define-key key-minor-mode-map (kbd "M-t") 'transpose-words)

# (define-key key-minor-mode-map (kbd "M--") 'cycle-hyphenation-or-toggle-item)

# (define-key key-minor-mode-map (kbd "s-'") 'refile-region-or-subtree)

# (define-key key-minor-mode-map (kbd "C-c j") 'helm-org-headlines) ; also bound to keychord jj
# (define-key key-minor-mode-map (kbd "C-x b") 'helm-mini) ; shows recent files; also bound to ⌘-r
# (define-key key-minor-mode-map (kbd "M-b M-d") 'book-dired) ; show directory of my book folder
# (define-key key-minor-mode-map (kbd "M-b r") 'read-a-book) ; show directory of my PDF books
# (define-key key-minor-mode-map (kbd "M-b j") 'read-jd) ; show PDF books I have annotated
# (define-key key-minor-mode-map (kbd "M-b M-b") 'work-on-book) ;

# (define-key key-minor-mode-map (kbd "M-b M-w") 'work-on-book) ;

# (define-key key-minor-mode-map (kbd "M-b lc") 'book-load-current) ;

# ;; (define-key key-minor-mode-map (kbd "M-b ho") 'spacemacs/toggle-highlight-current-line-globally)


# ;; book bindings
# (define-key key-minor-mode-map (kbd "M-b M-p") 'book-proposal-directory)
# (define-key key-minor-mode-map (kbd "M-b M-m") 'book-mistakes-directory)

# (define-key key-minor-mode-map (kbd "M-b M-r") 'book-helm-strict) ; this is a smart function, show recent files in my book folder

# ;; can't get this to work. for some reason GNU Emacs interprets ⌘-shift-d as s-c
# (define-key key-minor-mode-map (kbd "s-D") 'bjm/ivy-dired-recent-dirs)

# ;; own structure editing
# (define-key key-minor-mode-map (kbd "s-o") 'move-region-to-other-window) ; very useful when working with a split frame
# (define-key org-mode-map (kbd "s-o") 'move-region-to-other-window)


# (define-key key-minor-mode-map (kbd "s-j o l") 'olivetti-mode)
# (define-key key-minor-mode-map (kbd "] ol") 'olivetti-mode)
# (define-key key-minor-mode-map (kbd "s-j o e") 'olivetti-expand)
# (define-key key-minor-mode-map (kbd "s-+") 'olivetti-expand)
# (define-key key-minor-mode-map (kbd "s-_") 'olivetti-shrink)

# (define-key key-minor-mode-map (kbd "s-l") 'org-insert-link)


# ;; For extracting content from my browser

# (define-key key-minor-mode-map (kbd "s-W") 'org-mac-chrome-insert-frontmost-url)
# ;; (define-key key-minor-mode-map (kbd "s-V") 'kdm/html2org-clipboard) ; paste HTML content that I've copied from the web, automatically converting to proper org-mode syntax


# ;; indirect buffer
# (define-key key-minor-mode-map (kbd "s-I") 'clone-indirect-buffer-other-window)



# ;; and the keybinding
# (define-key org-mode-map (kbd "C-k") 'my/kill-line-dwim)
# (define-key key-minor-mode-map (kbd "C-k") 'my/kill-line-dwim)

# ;; use OSX standard keybindings ⌘-up and ⌘-down to go to top or bottom of buffer
# (define-key key-minor-mode-map [s-up] 'beginning-of-buffer)
# (define-key key-minor-mode-map [s-down] 'end-of-buffer)

# (define-key key-minor-mode-map (kbd "S-s-SPC") 'set-mark-command)

# ;; mark commands 
# (define-key key-minor-mode-map (kbd "C-M-SPC") 'set-mark-command)
# (define-key key-minor-mode-map (kbd "C-M-x") 'exchange-point-and-mark)


# (define-key key-minor-mode-map (kbd "C-s-SPC") 'helm-all-mark-rings)

# ; (define-key key-minor-mode-map (kbd "s-+") 'set-mark-command)

# ;; (define-key key-minor-mode-map (kbd "s-_") 'avy-pop-mark)
# ;; use OSX standard keybinding for "Redo"
# (define-key key-minor-mode-map (kbd "s-y") 'undo-tree-redo)

# ;; use OSX standard keybinding to increase or decrease font size
# ;; (define-key key-minor-mode-map (kbd "s-=") 'text-scale-increase)
# ;; (define-key key-minor-mode-map (kbd "s--") 'text-scale-decrease)

# (define-key key-minor-mode-map (kbd "s-=") 'embiggen-text)
# (define-key key-minor-mode-map (kbd "s--") 'ensmallen-text)


# ;; rebind global help command so that I can use C-h for backspace
# (define-key key-minor-mode-map (kbd "M-h") 'help-command)

# ;; very useful when encountering names and other unfamiliar words
# (define-key key-minor-mode-map (kbd "M-+") 'add-word-to-personal-dictionary)

# (define-key key-minor-mode-map (kbd "s-j s w") 'crux-swap-windows)

# (define-key key-minor-mode-map (kbd "s-j l a") 'jay-load-latex)
# (define-key key-minor-mode-map (kbd "s-j l t") 'jay-load-latex)
# (define-key key-minor-mode-map (kbd "s-j k a") 'load-koma-letter)
# (define-key key-minor-mode-map (kbd "s-j k o") 'load-koma-letter)

# (define-key key-minor-mode-map (kbd "M-s-v") 'kdm/html2org-clipboard)


# ;; navigate between buffers, including uninteresting ones that are hidden by default
# (define-key key-minor-mode-map (kbd "M-s-<right>") 'switch-to-next-buffer)
# (define-key key-minor-mode-map (kbd "M-s-<left>") 'previous-buffer)

# ;; deleting things
# ;; (define-key key-minor-mode-map (kbd "<backspace>") 'my/delete-backward)
# (define-key key-minor-mode-map (kbd "<backspace>") 'my/delete-backward-and-capitalize)

# ;; a keybinding for "delete" in addition to "backspace"
# (define-key key-minor-mode-map (kbd "C-<backspace>") 'delete-char)
# (define-key key-minor-mode-map (kbd "M-<backspace>") 'backward-kill-word-correctly-and-capitalize)

# ;; pomodoro
# (define-key key-minor-mode-map (kbd "C-c C-x pi") 'pomodoro-start)
# (define-key key-minor-mode-map (kbd "C-c C-x po") 'pomodoro-stop)

# ;; find files using helm
# (define-key key-minor-mode-map (kbd "C-x C-f") 'helm-find-files)

# ;; search using helm-swoop
# (global-set-key (kbd "M-I") 'helm-swoop-back-to-last-point)
# (global-set-key (kbd "C-c M-i") 'helm-multi-swoop)
# (global-set-key (kbd "C-x M-i") 'helm-multi-swoop-all)
# (global-set-key (kbd "M-i") 'helm-multi-swoop-all)

# ;; edit Emacs preferences using standard OSX keybinding for preferences
# (define-key key-minor-mode-map (kbd "s-,") 'customize-group)

# ;; grep, using current project as default
# (define-key key-minor-mode-map (kbd "s-G") 'helm-projectile-grep)

# ;; ag, using current folder as default
# ;; (define-key key-minor-mode-map (kbd "C-u s-g") 'helm-ag)
# ;; does that keyvinding work?

# ;; some custom functions

# (define-key key-minor-mode-map (kbd "C-c v i") 'org-insert-src-block)

# ;; org-mime
# ;; (define-key org-mode-map (kbd "M-n") 'new-email-from-subtree-no-signature)
# ;; (define-key key-minor-mode-map (kbd "M-N") 'new-email-from-subtree)


# #+END_SRC
* sentences

Make ~kill-sentence~ work in a more intuitive way:
#+BEGIN_SRC emacs-lisp
(defun kill-sentence-to-period ()
  "Leave the period in there."
  (interactive)
  (kill-sentence)
  (push-mark)
  (insert ".")
  (backward-char)
)
#+END_SRC

[[http://emacs.stackexchange.com/questions/12266/how-change-behavior-of-kill-sentence-based-on-position-in-sentence/12321?iemail=1&noredirect=1#12321][Source]]

#+BEGIN_SRC emacs-lisp
(defun my/forward-to-sentence-end ()
  "Move point to just before the end of the current sentence."
  (forward-sentence)
  (backward-char)
  (unless (looking-back "[[:alnum:]]")
    (backward-char)))

(defun my/beginning-of-sentence-p ()
  "Return  t if point is at the beginning of a sentence."
  (let ((start (point))
        (beg (save-excursion (forward-sentence) (forward-sentence -1))))
    (eq start beg)))

(defun my/kill-sentence-dwim ()
  "Kill the current sentence up to and possibly including the punctuation.
When point is at the beginning of a sentence, kill the entire
sentence. Otherwise kill forward but preserve any punctuation at the sentence end."
  (interactive)
(smart-expand)
  (if (my/beginning-of-sentence-p)
      (progn
        (kill-sentence)
        (just-one-space)
        (when (looking-back "^[[:space:]]+") (delete-horizontal-space)))
      (kill-region (point) (progn (my/forward-to-sentence-end) (point)))
      (just-one-space 0))

;; don't leave two periods in a row
(when
(or
(looking-at "\\.\\. ")
(and
(looking-at "\\.")
(looking-back "\\.")
)
)
(delete-forward-char 1))

(when
    (and
     (looking-at ".")
     (looking-back ",")
     )
  (delete-backward-char 1)
  (forward-char 1)
  )

)
#+END_SRC
* my/kill-line-dwim...???

#+BEGIN_SRC emacs-lisp


(defun my/kill-line-dwim ()
  "Kill the current line."
  (interactive)
;; don't leave stray stars behind when killing a line
(when
(or
(looking-back "\\[")
(looking-back "\* ")
(looking-back "\* TODO ")
(looking-back "^\*+")
(looking-back "- ")
(looking-back "# ")
)
(beginning-of-line)
)
;;  (expand-abbrev)
  (org-kill-line)
;;  (save-excursion
;;    (when (my/beginning-of-sentence-on)
;;      (capitalize-unless-org-heading)))
)
#+END_SRC

* kill-sentence-maybe-else-kill-line...???


  #+BEGIN_SRC emacs-lisp
(defun kill-sentence-maybe-else-kill-line ()
  (interactive)
(when
    (not (looking-at "$"))
  (my/kill-sentence-dwim))
  (when
      (looking-at "$")
    (my/kill-line-dwim))
)
;; and the keybinding
(global-set-key (kbd "M-k") 'kill-sentence-maybe-else-kill-line)

  #+END_SRC

* Browsing

#+BEGIN_SRC emacs-lisp
(setq browse-url-browser-function 'browse-url-default-macosx-browser)
#+END_SRC
* smart-space...???
#+BEGIN_SRC emacs-lisp
(defun smart-period-or-smart-space ()
"double space adds a period!"
(interactive)
  (if
(looking-back "[A-Za-z0-9] ")
(smart-period)
(smart-space)
))

(defun smart-space ()
  "Insert space and then clean up whitespace."
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point)))))

;; (if (org-at-heading-p)
 ;;    (insert-normal-space-in-org-heading)

  (unless
      (or
(let ((case-fold-search nil)
(looking-back "\\bi\.e[[:punct:][:punct:]]*[ ]*") ; don't add extra spaces to ie.
)
(looking-back "\\bvs.[ ]*") ; don't add extra spaces to vs.
(looking-back "\\be\.\g[[:punct:]]*[ ]*") ; don't add extra spaces to eg.

(looking-back "^[[:punct:]]*[ ]*") ; don't expand previous lines - brilliant!

(looking-back ">") ; don't expand days of the week inside timestamps

(looking-back "][\n\t ]*") ; don't expand past closing square brackets ]
       ))
  (smart-expand))

(insert "\ ")
(just-one-space)
)




;; this is probably convuluted logic to invert the behavior of the SPC key when in org-heading
(defun insert-smart-space-in-org-heading ()
 "Insert space and then clean up whitespace."
 (interactive)
(unless
   (or
(looking-back "\\bvs.[ ]*") ; don't add extra spaces to vs.
(looking-back "\\bi\.e[[:punct:][:punct:]]*[ ]*") ; don't add extra spaces to ie.
(looking-back "\\be\.\g[[:punct:][:punct:]]*[ ]*") ; don't add extra spaces to eg.

(looking-back "^[[:punct:][:punct:]]*[ ]*") ; don't expand previous lines---brilliant!

(looking-back ">") ; don't expand days of the week inside timestamps

(looking-back "][\n\t ]*") ; don't expand past closing square brackets ]
    )
 (smart-expand))
(insert "\ ")
 (just-one-space))



; (define-key org-mode-map (kbd "<SPC>") 'smart-period-or-smart-space) ; I disabled this for DragonSpeak 
(define-key org-mode-map (kbd "<SPC>") 'smart-space)
;; (define-key orgalist-mode-map (kbd "<SPC>") 'smart-period-or-smart-space)
(global-set-key (kbd "M-SPC") 'insert-space)
(define-key org-mode-map (kbd "<M-SPC>") 'insert-space)
;; (define-key orgalist-mode-map (kbd "<M-SPC>") 'insert-space)


#+END_SRC

* my/fix-space...???
#+BEGIN_SRC emacs-lisp
;;; I changed this a)) bunch, not sure if it still works correctly.
;; (defun my/fix-space ()
;;   "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
;;   (interactive)
;;   (just-one-space)
;;
;;     (when (or
;;            (looking-back "^[[:space:]]+")
;;            (looking-back "-[[:space:]]+")
;;            (looking-at "[.,:;!?»)-]")
;;            (looking-back"( ")
;;            (looking-at " )")
;;            ))
;;       (unless
;;       (looking-back "^-[[:space:]]+")
;;   (delete-horizontal-space))
;;
;; (unless
;;  (looking-back "^")
;; (just-one-space)
;; )
;;
;; )

(defun my/fix-space ()
  "Delete all spaces and tabs around point, leaving one space except at the beginning of a line and before a punctuation mark."
  (interactive)
  (just-one-space)
  (when (and (or
              (looking-back "^[[:space:]]+")
              (looking-back "-[[:space:]]+")
              (looking-at "[.,:;!?»)-]")
              (looking-back"( ")
              (looking-at " )")
              )
             (not (looking-back "^-[[:space:]]+"))
             (not (looking-back " - "))

)
    (delete-horizontal-space)))
#+END_SRC

* insert-space
#+BEGIN_SRC emacs-lisp


(defun insert-space ()
  (interactive) 
(if (org-at-heading-p)
(insert-smart-space-in-org-heading)
(cond (mark-active
   (progn (delete-region (mark) (point)))))
  (insert " ")
)) 

(defun insert-normal-space-in-org-heading ()
 (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point))))) 
 (insert " ")
)

;; this is probably convuluted logic to invert the behavior of the SPC key when in org-heading


(defun insert-period ()
"Inserts a fuckin' period!"
 (interactive)
(cond (mark-active
   (progn (delete-region (mark) (point)))))

 (insert ".")
)


(defun insert-comma ()
 (interactive)
(cond (mark-active
   (progn (delete-region (mark) (point))))) 
 (insert ",")
)

(defun insert-exclamation-point ()
 (interactive)
(cond (mark-active
  (progn (delete-region (mark) (point)))))
 (insert "!")
)


(defun insert-colon ()
"Insert a goodamn colon!"
 (interactive)
(cond (mark-active
  (progn (delete-region (mark) (point))))) 
 (insert ":")
) 

(defun insert-question-mark ()
"Insert a freaking question mark!!"
 (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point))))) 
 (insert "?")
) 


#+END_SRC
* smart-org-meta-return-dwim...???
 #+BEGIN_SRC emacs-lisp
(setq org-blank-before-new-entry
      '((heading . always)
       (plain-list-item . always)))

(defun call-rebinding-org-blank-behaviour (fn)
  (let ((org-blank-before-new-entry
         (copy-tree org-blank-before-new-entry)))
    (when (org-at-heading-p)
      (rplacd (assoc 'heading org-blank-before-new-entry) nil))
    (call-interactively fn)))

(defun smart-org-meta-return-dwim ()
  (interactive)

(if

    (and
     (looking-back "^")
     (looking-at ".+")
     )                               ; if
    (org-toggle-heading-same-level) ; then
 (call-rebinding-org-blank-behaviour 'org-meta-return)) ; else
)


#+END_SRC

* smart-org-insert-heading-respect-content-dwim...???
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-heading-respect-content-dwim ()
(interactive)
  (call-rebinding-org-blank-behaviour 'org-insert-heading-respect-content)
)
#+END_SRC

* smart-org-insert-todo-heading-dwim...???
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-todo-heading-dwim ()
  (interactive)
  (let ((listitem-or-checkbox (org-plain-text-list-p)))
    (call-rebinding-org-blank-behaviour 'org-insert-heading)
    (if listitem-or-checkbox
        (insert "[ ] ")
        (insert "TODO ")))
)

#+END_SRC

* smart-org-insert-todo-heading-respect-content-dwim...???
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-todo-heading-respect-content-dwim ()
  (interactive)
  (call-rebinding-org-blank-behaviour 'org-insert-todo-heading-respect-content)
)
#+END_SRC

* smart-org-insert-subheading...???
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-subheading ()
  (interactive)
(call-rebinding-org-blank-behaviour 'org-meta-return)
(org-demote-subtree)
)
#+END_SRC

* smart-org-insert-todo-subheading...???
#+BEGIN_SRC emacs-lisp
(defun smart-org-insert-todo-subheading ()
  (interactive)
(call-rebinding-org-blank-behaviour 'org-insert-todo-subheading)
)
#+END_SRC
* length of previous line
#+BEGIN_SRC emacs-lisp

(defun length-of-previous-line ()
 (save-excursion
  (forward-line -1)
  (end-of-line)
  (current-column)))
#+END_SRC

* smart-return
#+BEGIN_SRC emacs-lisp

  (defun smart-return ()
    (interactive)

    ;; don't leave stray stars or links
    (when
	(or
	 (looking-back "\\[")
	 (looking-back "^\*+[ ]*") ; hopefully this means: at the beginning of the line, 1 or more asterisks followed by zero or more spaces
	 (looking-back "^# ")
	 ;; (looking-back "* TODO ") ; actually I don't think I want this
	 ;; (looking-back "^*+")
	 ;; (looking-back "- ")
	 )
      (beginning-of-line)
      )
    ;;
    (cond (mark-active
	   (progn (delete-region (mark) (point))
		  (newline)))
	  ;; Lifted from `org-return'. Why isn't there an
	  ;; `org-at-link-p' function?!
	  ((and 
	    org-return-follows-link
	    (org-in-regexp org-any-link-re))
	   (cond
	    ((or
	      ;;(looking-at "\\[\\[.*")
	      (looking-back ">")
	      (looking-back "\\]\\]")
	      (and (thing-at-point 'url)
		   (let ((bnds (bounds-of-thing-at-point 'url)))
		     (or (>= (car bnds) (point))
			 (<= (cdr bnds) (point))))))
	     (newline))
	    ((char-equal (string-to-char "]") (following-char))
	     (progn (forward-char 2)
		    (newline)))
	    (t (call-interactively 'org-open-at-point))))

	  ;; ((and 
	  ;;   (let ((el (org-element-at-point)))
	  ;;   (and el
	  ;;   ;; point is at an item
	  ;;   (eq (first el) 'item)
	  ;;   ;; item is empty
	  ;;   (eql (getf (second el) :contents-begin)
	  ;;   (getf (second el) :contents-end)))))
	  ;;  (message "at 1")
	  ;;  (beginning-of-line)
	  ;;  (let ((kill-whole-line nil))
	  ;;    (kill-line))
	  ;;  (newline))
	  ;; ((and 
	  ;;   (let ((el (org
	  ;; 	     -element-at-point)))
	  ;;     (and (not (org--line-empty-p 1))
	  ;; 	 (and el
	  ;; 	      (or (member (first el) '(item plain-list))
	  ;; 		  (let ((parent (getf (second el) :parent)))
	  ;; 		    (and parent
	  ;; 			 (member (first parent) '(item plain-list)))))))))
	  ;;  (let ((is-org-chbs (org-checkbox-p)))
	  ;;    (org-run-like-in-org-mode (lambda () (interactive) (call-interactively 'org-meta-return)))
	  ;;    (when is-org-chbs
	  ;;      (insert "[ ] "))))
	  ;; ((and
	    ;; (not (and
		  ;; org-return-follows-link
		  ;; (looking-back ">"))))
	   ;; (org-run-like-in-org-mode (lambda () (interactive) (call-interactively 'org-return))))
	  (t (newline))))

  (define-key org-mode-map (kbd "<return>") 'smart-return)
  ;; (define-key orgalist-mode-map (kbd "<return>") 'smart-return)
#+END_SRC

* kill word correctly...???

#+BEGIN_SRC emacs-lisp
(defun kill-word-correctly ()
  "Kill word."
  (interactive)
  (smart-expand)
  (if (or (re-search-forward "\\=[ 	]*\n" nil t)
          (re-search-forward "\\=\\W*?[[:punct:]]+" nil t)) ; IF there's a sequence of punctuation marks at point
      (kill-region (match-beginning 0) (match-end 0)) ; THEN just kill the punctuation marks
    (kill-word 1))                                    ; ELSE kill word
  (my/fix-space)
;; don't leave two periods in a row
(when 
(or
(looking-at "\\,\\, ")

(and 
(looking-at "\\,")
(looking-back "\\,") 
)
)
(delete-forward-char 1))
)

#+END_SRC

* kill word correctly and capitalize...???

#+BEGIN_SRC emacs-lisp
(defun kill-word-correctly-and-capitalize ()
  "Check to see if the point is at the beginning of the sentence. If yes, then kill-word-correctly and endless/capitalize to capitalize the first letter of the word that becomes the first word in the sentence. Otherwise simply kill-word-correctly."
  (interactive)
(when (looking-at "[ ]")
         (forward-char 1)
          )
;; capitalize correctly if there's point is before the space at the beginning of a sentence 
 
  (let ((fix-capitalization (my/beginning-of-sentence-p)))
    (call-interactively 'kill-word-correctly)
    (when fix-capitalization
      (save-excursion (capitalize-unless-org-heading)))))
#+END_SRC

* character movement* Emacs Lisp Mode
#+BEGIN_EXAMPLE emacs-lisp
(defun turn-on-autocomplete-mode ()
   (auto-complete-mode 1))
(add-hook 'emacs-lisp-mode-hook 'turn-on-autocomplete-mode )
#+END_EXAMPLE 

* Reference for cleaning up whitespace around sentences:
[[http://stackoverflow.com/questions/4754547/redefining-sentence-in-emacs-single-space-between-sentences-but-ignoring-ab][regex - Redefining "sentence" in Emacs? (single space between sentences, but ignoring abbreviations) - Stack Overflow]]

* cycle-hyphenation

#+BEGIN_SRC emacs-lisp
(defun cycle-hyphenation ()
  (interactive)
  (cond ((re-search-forward "\\=\\w*\\(-\\)\\w+" nil t)
         (save-excursion (replace-match " " t t nil 1)))
        ((re-search-forward "\\=\\w*\\( +\\)\\w+" nil t)
         (save-excursion (replace-match "-" t t nil 1)))))
#+END_SRC

* cycle-punctuation

#+BEGIN_SRC emacs-lisp
(defvar *punctuation-markers-to-cycle-between*  ".?!")

(defun cycle-punctuation ()
  (interactive)
  (save-excursion
    (forward-sentence)
    (when (re-search-backward (format "\\>\\([%s]\\)[[:space:]]*\\="
                                      *punctuation-markers-to-cycle-between*)
                              nil t)
      (let ((next (elt *punctuation-markers-to-cycle-between*
                       ;; circular string; should be abstracted
                       (mod (1+ (position (elt (match-string 1) 0)
                                          *punctuation-markers-to-cycle-between*))
                            (length *punctuation-markers-to-cycle-between*)))))
        (replace-match (format "%c" next) t t nil 1)))))

;; (define-key key-minor-mode-map (kbd "M-.") 'cycle-punctuation)
#+END_SRC

#+BEGIN_SRC emacs-lisp

(defun jay/left-char ()
  "Move point to the left or the beginning of the region.
 Like `backward-char', but moves point to the beginning of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'left-char)) ;; maintain compatibility
    (let ((left (min (point)
                     ;; `mark' returning nil is ok; we'll only use this
                     ;; if `mark-active'
                     (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn
            (goto-char left)
            (setq deactivate-mark t))
        (call-interactively 'left-char)))))


(defun jay/right-char ()
  "Move point to the right or the end of the region.
 Like `right-char', but moves point to the end of the region
provided the (transient) mark is active."
  (interactive)
  (let ((this-command 'right-char)) ;; maintain compatibility
    (let ((right (max (point)
                      ;; `mark' returning nil is ok; we'll only use this
                      ;; if `mark-active'
                      (or (mark t) 0))))
      (if (and transient-mark-mode mark-active)
          (progn (goto-char right)
		 (setq deactivate-mark t))
	(call-interactively 'right-char)))))

(define-key org-mode-map (kbd "<left>") 'jay/left-char)
(define-key org-mode-map (kbd "<right>") 'jay/right-char)

#+END_SRC
* kill-clause...???

This version kill org-mode headings by 'kill-line'
#+BEGIN_EXAMPLE emacs-lisp

;; Identify the end of sentences globally.
(setq sentence-end-base "[][.?!…}]+[\"”]?")
(defun kill-clause ()
  (interactive)
  (smart-expand)
  (if (let ((sm (string-match "[*]+\s" (thing-at-point 'line)))) (and sm (= sm 0)))
      (kill-line)
    (progn
      (let ((old-point (point))
            (kill-punct (my/beginning-of-sentence-p)))
        (when (re-search-forward "--\\|[][,;:?!…\"”()}]+\\|\\.+ " nil t)
          (kill-region old-point
                       (if kill-punct
                           (match-end 0)
                         (match-beginning 0)))))

      (my/fix-space)
      (save-excursion
        (when (my/beginning-of-sentence-p)
          (capitalize-unless-org-heading)))

;; below is my own hack to fix the ", , " issue
(when

(or

(looking-back ", , ")
(looking-back ",, ")
(looking-back ",, ")
(looking-back ": : ")
)
(new-org-delete-backward-char 2) 
(my/fix-space)


(when
(and
(looking-back "----")
(looking-at "-"))

(delete-backward-char 4)
(delete-char 1)
(insert-space))


t)))

#+END_EXAMPLE


This old version leaves a rogue comma:
#+BEGIN_EXAMPLE emacs-lisp

;; Identify the end of sentences globally.
(setq sentence-end-base "[][.?!…}]+[\"”]?")
(defun kill-clause ()
  (interactive)
  (smart-expand)
  (let ((old-point (point))
        (kill-punct (my/beginning-of-sentence-p)))
    (when (re-search-forward "--\\|[][,;:?!…\"”()}]+\\|\\.+ " nil t)
      (kill-region old-point
                   (if kill-punct
                       (match-end 0)
                     (match-beginning 0)))))
  (my/fix-space)
  (save-excursion
    (when (my/beginning-of-sentence-p)
      (capitalize-unless-org-heading))))

#+END_EXAMPLE

Old version that I retrieved:
#+BEGIN_SRC emacs-lisp
(defun kill-clause ()
  (interactive)
  (smart-expand)

(if
(let ((sm (string-match "*+\s" (thing-at-point 'line)))) (and sm (= sm 0)))
(kill-line)


  (let ((old-point (point))
        (kill-punct (my/beginning-of-sentence-p)))
    (when (re-search-forward "--\\|[][,;:?!…\"”()}]+\\|\\.+ " nil t)
      (kill-region old-point
                   (if kill-punct
                       (match-end 0)
                     (match-beginning 0)))))
  (my/fix-space)
  (save-excursion
    (when (my/beginning-of-sentence-p)
      (capitalize-unless-org-heading)))

(when
(or    (looking-back ", , ")
     (looking-back ":: ")
     )
(new-org-delete-backward-char 2)
(my/fix-space)
t)

;; fix a bug that leaves this: " : "
(when (looking-back " : ")
(progn
(left-char 2)
(new-org-delete-backward-char 1)
(right-char 2)
))


;; fix a bug that leaves this: " , "
(when (looking-back " , ")
(progn
(left-char 2)
(my/fix-space)
(right-char 2)
))


;; fix a bug that leaves this: ",."
(when (looking-back ",. ")
(left-char 2)
(delete-backward-char 1)
(right-char 2)
)


;; fix a bug that leaves this: ", . "
(when (looking-back ", . ")
(left-char 2)
(delete-backward-char 2)
(right-char 2)
)

(when
(and
(looking-back "----")
(looking-at "-"))

(delete-backward-char 4)
(delete-char 1)
(insert-space))



))
#+END_SRC
* smart-punctuation exceptions...???

   #+BEGIN_SRC emacs-lisp
(defvar *smart-punctuation-marks*
  ".,;:!?-")

(setq *smart-punctuation-exceptions*
  (list "?!" ".." "..." "............................................." "---" ";;" "!!" "!!!" "??" "???" "! :" ". :" ") ; "))

;; How do I add an exception for ") ; "?
;; e.g. if I want to add a comment after a line of lisp?

   #+END_SRC

* smart-punctuation (auxiliary)...???

#+BEGIN_SRC emacs-lisp
  (defun smart-punctuation (new-punct &optional not-so-smart)
    (smart-expand)
    (save-restriction
      (when (and (eql major-mode 'org-mode)
                 (org-at-heading-p))
        (save-excursion
          (org-beginning-of-line)
          (let ((heading-text (fifth (org-heading-components))))
            (when heading-text
              (search-forward heading-text)
              (narrow-to-region (match-beginning 0) (match-end 0))))))
      (cl-flet ((go-back (regexp)
                  (re-search-backward regexp nil t)
                  (ignore-errors      ; might signal `end-of-buffer'
                    (forward-char (length (match-string 0))))))
        (if not-so-smart
            (let ((old-point (point)))
              (go-back "[^ \t]")
              (insert new-punct)
              (goto-char old-point)
              (forward-char (length new-punct)))
          (let ((old-point (point)))
            (go-back (format "[^ \t%s]\\|\\`" *smart-punctuation-marks*))
            (let ((was-after-space (and (< (point) old-point)
                                        (find ?  (buffer-substring (point) old-point)))))
              (re-search-forward (format "\\([ \t]*\\)\\([%s]*\\)"
                                         ,*smart-punctuation-marks*)
                                 nil t)
              (let* ((old-punct (match-string 2))
                     (was-after-punct (>= old-point (point))))
                (replace-match "" nil t nil 1)
                (replace-match (or (when (and was-after-punct
                                              (not (string= old-punct "")))
                                     (let ((potential-new-punct (concat old-punct new-punct)))
                                       (find-if (lambda (exception)
                                                  (search potential-new-punct exception))
                                                ,*smart-punctuation-exceptions*)))
                                   new-punct)
                               nil t nil 2)
                (if was-after-space
                    (my/fix-space)
                  (when (looking-at "[ \t]*\\<")
                    (save-excursion (my/fix-space))))))))))
    (when (and (eql major-mode 'org-mode)
               (org-at-heading-p))
; (org-align-tags-here org-tags-column)
))
#+END_SRC

* smart-period
#+BEGIN_SRC emacs-lisp
(defun smart-period ()
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point))))) 
(unless
      (or
(looking-back "\\bvs.[ ]*") ; Don't add extra periods to vs.
(looking-back "\\bi\.e[[:punct:]]*[ ]*") ; don't add extra periods to ie.
(looking-back "\\be\.\g[[:punct:]]*[ ]*") ; don't add extra periods to eg.

       )
  (smart-punctuation "."))
  (save-excursion
    (unless
        (or
         (looking-at "[ ]*$")
         (looking-at "\][[:punct:]]*[ ]*$")
         (looking-at "[[:punct:]]*[ ]*$")
         (looking-at "\"[[:punct:]]*[ ]*$")
         (looking-at "\)[ ]*$")
         (looking-at "\)")
         ) ; or
    (capitalize-unless-org-heading)
      ) ; unless
) ; save excursion

;; if two periods or two commas in a row, delete the second one 
(when 
(or
(and
(looking-at "\\.")
(looking-back "\\.")
) 
(and
(looking-at ",")
(looking-back ",")
))
(delete-char 1)
)

  ) ; defun


(define-key org-mode-map (kbd ".") 'smart-period)
;; (define-key orgalist-mode-map (kbd ".") 'smart-period)
#+END_SRC

* smart-comma
#+BEGIN_SRC emacs-lisp
(defun smart-comma ()
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point))))) 

  (smart-punctuation ",")
(unless
(or

(looking-at "\]*[[:punct:]]*[ ]*$")
(looking-at "[[:punct:]]*[ ]*$")
(looking-at "[ ]*I\\b")          ; never downcase the word "I"
(looking-at "[ ]*I\'")          ; never downcase the word "I'
(looking-at "[[:punct:]]*[ ]*\"")          ; beginning of a quote
)

(save-excursion (downcase-word 1)))
(when

;; if two periods or two commas in a row, delete the second one
(or
(and
(looking-at "\\.")
(looking-back "\\.")
) 
(and
(looking-at ",")
(looking-back ",")
))
(delete-char 1)
)

)


(define-key org-mode-map (kbd ",") 'comma-or-smart-comma)
;; (define-key orgalist-mode-map (kbd ",") 'comma-or-smart-comma)
#+END_SRC

* smart-question-mark
#+BEGIN_SRC emacs-lisp
(defun smart-question-mark ()
  (interactive)
  (cond (mark-active
         (progn (delete-region (mark) (point))))) 

  (smart-punctuation "?")
  (save-excursion
    (unless
        (or
         (looking-at "[ ]*$")
         (looking-at "\][[:punct:]]*[ ]*$")
         (looking-at "[[:punct:]]*[ ]*$")
         (looking-at "\"[[:punct:]]*[ ]*$")
         (looking-at "\)[ ]*$")
         (looking-at "\)")
         ) ; or
    (capitalize-unless-org-heading)
      ) ; unless
    ) ; save excursion
  ) ; defun

;; works!!

(define-key org-mode-map (kbd "?") 'smart-question-mark)
;; (define-key orgalist-mode-map (kbd "?") 'smart-question-mark)
#+END_SRC

* smart-exclamation-point
#+BEGIN_SRC emacs-lisp
(defun smart-exclamation-point ()
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point))))) 

  (smart-punctuation "!")
(save-excursion
(unless (looking-at "[ ]*$")
(capitalize-unless-org-heading))
))

(define-key org-mode-map (kbd "!") 'smart-exclamation-point)
;; (define-key orgalist-mode-map (kbd "!") 'smart-exclamation-point)
#+END_SRC

* smart-hyphen
(defun smart-hyphen ()
  (interactive)
  (smart-punctuation "-"))

(define-key org-mode-map (kbd "-") 'smart-hyphen)
;; (define-key orgalist-mode-map (kbd "-") 'smart-hyphen)
#+END_SRC

* smart-semicolon

#+BEGIN_SRC emacs-lisp
(defun smart-semicolon ()
  (interactive)
(cond (mark-active
 (progn (delete-region (mark) (point))))) 
  (smart-punctuation ";")
(unless
(or
(looking-at "[[:punct:]]*[ ]*$")
(looking-at "[ ]*I\\b")     ; never downcase the word "I"
(looking-at "[ ]*I\'")     ; never downcase the word "I'
(looking-at "[[:punct:]]*[ ]*\"")     ; beginning of a quote
)

(save-excursion (downcase-word 1))))

(define-key org-mode-map (kbd ";") 'smart-semicolon)
;; (define-key orgalist-mode-map (kbd ";") 'smart-semicolon)
#+END_SRC

* smart-colon

#+BEGIN_SRC emacs-lisp
(defun smart-colon ()
  (interactive)
(cond (mark-active
  (progn (delete-region (mark) (point))))) 
  (smart-punctuation ":")
(unless
(or
(looking-at "[[:punct:]]*[ ]*$")
(looking-at "[ ]*I\\b")     ; never downcase the word "I"
(looking-at "[ ]*I\'")     ; never downcase the word "I'
(looking-at "[[:punct:]]*[ ]*\"")     ; beginning of a quote
)

;; (save-excursion (downcase-word 1))
))


(define-key org-mode-map (kbd ":") 'colon-or-smart-colon)
(define-key org-mode-map (kbd ",") 'comma-or-smart-comma)
;; (define-key orgalist-mode-map (kbd ":") 'smart-colon) 
#+END_SRC

* comma-or-smart-comma
#+BEGIN_SRC emacs-lisp
(defun comma-or-smart-comma ()
(interactive) 
(if 
(or
(bolp)
(org-at-heading-p)
(looking-at " \"")
) 
(insert ",")
(smart-comma))
) 
#+END_SRC

* colon-or-smart-colon
#+BEGIN_SRC emacs-lisp
(defun colon-or-smart-colon ()
(interactive)
(if
(or
(bolp)
(org-at-heading-p)
)
(insert ":")
(smart-colon))
)
#+END_SRC
* backward-kill-word-correctly-and-capitalize...???
#+BEGIN_SRC emacs-lisp
(defun backward-kill-word-correctly-and-capitalize ()
  "Backward kill word correctly. Then check to see if the point is at the beginning of the sentence. If yes, then kill-word-correctly and endless/capitalize to capitalize the first letter of the word that becomes the first word in the sentence. Otherwise simply kill-word-correctly."
  (interactive)
(call-interactively 'backward-kill-word-correctly)
  (let ((fix-capitalization (my/beginning-of-sentence-p)))
    (when fix-capitalization
      (save-excursion (capitalize-unless-org-heading)))))
#+END_SRC

* defadvice capitalize-word
#+BEGIN_SRC emacs-lisp
(defadvice capitalize-word (after capitalize-word-advice activate)
  "After capitalizing the new first word in a sentence, downcase the next word which is no longer starting the sentence."

  (unless
 
      (or
       (looking-at "[ ]*\"")          ; if looking at a quote? Might not work

       (looking-at "[[:punct:]]*[ ]*I\\b")          ; never downcase the word "I"
       (looking-at "[[:punct:]]*[ ]*I'")          ; never downcase words like I'm, I'd
       (looking-at "[[:punct:]]*[ ]*\"*I'")    ; never downcase words like I'm, I'd 

(looking-at "[ ]*I\'")   ; never downcase the word "I'

       (looking-at "[[:punct:]]*[ ]*\"I\\b")          ; never downcase the word "I"
       (looking-at "[[:punct:]]*[ ]*OK\\b")          ; never downcase the word "OK"

       ;; (looking-at "\\") ; how do you search for a literal backslash?
       (looking-at (sentence-end))

       (looking-at "[[:punct:]]*[ ]*$") ; don't downcase past line break 

       (looking-at "[[:punct:]]*[ ]*\"$") ; don't downcase past quotation then line break 
       (looking-at "[[:punct:]]*[ ]*)$") ; don't downcase past a right paren then line break 
       (looking-at "[[:punct:]]*[ ]*\")$") ; don't downcase past a quotation then a right paren then a line break 

       (looking-at "[[:punct:]]*[ ]*http") ; never capitalize http 

(looking-at "\"[[:punct:]]*[ ]*$") ; a quotation mark followed by "zero or more whitespace then end of line?"

(looking-at "\)[ ]*$") ; a right paren followed by "zero or more" whitespace, then end of line 

(looking-at ")[ ]*$") ; a right paren followed by "zero or more" whitespace, then end of line 
(looking-at ")$") ; a right paren followed by "zero or more" whitespace, then end of line 

(looking-at "[ ]*-*[ ]*$") ; dashes at the end of a line 


       (looking-at (user-full-name))

       )

    (save-excursion
      (downcase-word 1))))
#+END_SRC

I tried to add exceptions for "line-end" and also for user-full name.

* capitalize-unless-org-heading
  #+BEGIN_SRC emacs-lisp
(defun capitalize-unless-org-heading ()
  (interactive)
  (unless
      (or
       (looking-at "[[:punct:]]*[\n\t ]*\\*")
       ;; (looking-at "\\* TODO"); redundant
       (let ((case-fold-search nil))
         (looking-at "[ ]*[\n\t ]*[[:punct:]]*[\n\t ]*[A-Z]")
         (looking-at "[A-Z].*"))
       (looking-at "[\n\t ]*[[:punct:]]*[\n\t ]*#\\+")
       (looking-at "[\n\t ]*[[:punct:]]*[\n\t ]*\(")
       (looking-at "[\n\t ]*[[:punct:]]*[\n\t ]*<")
       (looking-at "[\n\t ]*[[:punct:]]*[\n\t ]*file:")
       (looking-at "[\n\t ]*\\[fn")
       (looking-at "[\n\t ]*)$")
       (looking-at "[\n\t ]*\"$")
       (looking-at "\"[\n\t ]*$")
       (looking-at "[[:punct:]]*[ ]*http")
       (looking-at "[[:punct:]]*[ ]*\")$"); don't capitalize past
       (looking-at "[ ]*I\'")
       (looking-at
        (concat
         "\\("
         (reduce (lambda (a b) (concat a "\\|" b))
                 auto-capitalize-words)
         "\\)")))
    (capitalize-word 1)))
  #+END_SRC

* downcase-save-excursion

  #+BEGIN_SRC emacs-lisp
(defun downcase-save-excursion ()
  (interactive)
(unless
(or
(looking-at "[[:punct:]]*[ ]*$") 
(looking-at "[ ]*I\\b") ; never downcase the word "I"
(looking-at "[[:punct:]]*[ ]*[[:punct:]]*I'")  ; never downcase I'm I've etc.
(looking-at "[[:punct:]]*[ ]*$") ; zero or more whitespaces followed by zero or more punctuation followed by zero or more whitespaces followed by a line break
(looking-at "\"[[:punct:]]*[ ]*$") ; a quotation mark followed by "zero or more whitespace then end of line?"
(looking-at "\)[ ]*$") ; a quotation mark followed by "zero or more whitespace then end of line?"
(looking-at (sentence-end)) ; quotation mark followed by "zero or more whitespace then end of line?"
       (looking-at (user-full-name))


)
  (save-excursion
      (downcase-word 1))
  ))
  #+END_SRC

* smart-expand
Don't expand past certain delimiters, e.g. line break, ), and "


#+BEGIN_SRC emacs-lisp

(defun smart-expand ()
  (interactive)

  (unless

    (or
       (looking-back "\)\n*")
(looking-back "[[:punct:]]*\)[ ]*[[:punct:]]*[\n\t ]*[[:punct:]]*>*")
(looking-back ":t[ ]*")
(looking-back "][\n\t ]*[[:punct:]]*[\n\t ]*") ; don't expand past closing square brackets ]

(looking-back ">[\n\t ]*[[:punct:]]*[\n\t ]*") ; don't expand past closing email addresses]


;; (looking-back "\\\w") ; for some reason this matches all words, not just ones that start with a backslash
)
    (expand-abbrev)
)
)

#+END_SRC




(defun smart-expand ()
  (interactive)

  (unless

    (or
       (looking-back "\)\n*")
(looking-back "\)[ ]*")
(looking-back ":t[ ]*")

;; (looking-back "\\\w") ; for some reason this matches all words, not just ones that start with a backslash
)
    (expand-abbrev)
)
)

* fountain...???
  #+BEGIN_SRC emacs-lisp
;; (load-file "/Users/jay/emacs/emacs-settings/fountain-mode.el")
;; (require 'fountain-mode)

;; (add-hook 'fountain-mode-hook 'turn-on-olivetti-mode)
(add-hook 'fountain-mode-hook '(lambda () (orgalist-mode 1)))
(add-hook 'fountain-mode-hook 'turn-on-auto-capitalize-mode 'append)

(defcustom fountain-export-default-command
  'fountain-export-shell-script
  "\\<fountain-mode-map>Default function to call with \\[fountain-export-default]."
  :type '(radio (function-item fountain-export-shell-script)
                (function-item fountain-export-buffer-to-html))
  :group 'fountain-export)

(defcustom fountain-export-shell-script
  "afterwriting --config ~/.config/afterwriting/config.json --source %s --pdf --overwrite"
  "Shell command string to convert Fountain source to ouput.
\"%s\" will be substituted with `buffer-file-name'"
  :type 'string
  :group 'fountain-export)

(defun fountain-export-shell-script (&optional buffer)
  "Call shell script defined in `fountain-export-shell-script'."
  (interactive)
  (let* ((buffer (or buffer (current-buffer)))
         (file (shell-quote-argument (buffer-file-name buffer)))
         (command (format fountain-export-shell-script file)))
    (async-shell-command command "*Fountain Export Process*")))

(setq fountain-export-include-title-page nil)
(setq fountain-export-html-replace-alist
   (quote
    (("&" "&amp;")
     ("<" "&lt;")
     (">" "&gt;")
     ("\\\\ " "&nbsp;")
     ("^\\\\$" "<br>")
     ("\\\\_" "&#95;")
     ("\\\\\\*" "&#42;")
     ("\\\\`" "&#96;")
     ("\\\\'" "&apos;")
     ("``" "&ldquo;")
     ("''" "&rdquo;")
     ("`" "&lsquo;")
     ("'" "&rsquo;")
     ("\\*\\*\\*\\(.+?\\)\\*\\*\\*" "<span class=\"underline\">\\1</span>")
     ("\\*\\*\\(.+?\\)\\*\\*" "<span class=\"underline\">\\1</span>")
     ("\\*\\(.+?\\)\\*" "<span class=\"underline\">\\1</span>")
     ("^~ *\\(.+?\\)$\\*\\*" "<i>\\1</i>")
     ("_\\(.+?\\)_" "<span class=\"underline\">\\1</span>")
     ("

+" "<br><br>")
     ("
" "<br>")))) 
  #+END_SRC

* display file name
How can I modify the titlebar to contain the current file name?

The contents of an Emacs frame's titlebar is controlled by the variable frame-title-format, which has the same structure as the variable mode-line-format. (Use C-h v or M-x describe-variable to get information about one or both of these variables.)

By default, the titlebar for a frame does contain the name of the buffer currently being visited, except if there is a single frame. In such a case, the titlebar contains Emacs invocation name and the name of the machine at which Emacs was invoked. This is done by setting frame-title-format to the default value of

(multiple-frames "%b" ("" invocation-name "@" system-name))
To modify the behavior such that frame titlebars contain the buffer's name regardless of the number of existing frames, include the following in your .emacs:


#+BEGIN_SRC emacs-lisp
;; (setq frame-title-format (concat "Hey bro, just FYI, this file is called %b or something like that."))
;; Changing this for Hook app compatibility per https://discourse.hookproductivity.com/t/integrating-emacs-and-hook-with-org-mode/932/5 
#+END_SRC

* Hook app...???
[[https://discourse.hookproductivity.com/t/integrating-emacs-and-hook-with-org-mode/932/10][Integrating Emacs and Hook, with org-mode - Discussion & Help - Hook Productivity Forum]]

#+begin_src emacs-lisp

(setq frame-title-format '((:eval buffer-file-name))) 

(defun my/hook (hook)
 "Create an org-link target string using `hook://` url scheme."
 (shell-command (concat "open \"" hook "\"")))

 (org-add-link-type "hook" 'my/hook) 
#+end_src
* capitalize sentence...ERROR
#+BEGIN_SRC emacs-lisp
  ;; (defun capitalize-sentence ()
  ;;   (interactive)
  ;; (unless (my/beginning-of-sentence-p)
  ;; (org-backward-sentence))
  ;;   (endless/capitalize)
  ;; (org-forward-sentence 1)
  ;; (jay/right-char)
  ;; )
  ;; (define-key key-minor-mode-map (kbd "M-C") 'capitalize-word)

#+END_SRC
* downcase sentence...ERROR
#+BEGIN_SRC emacs-lisp
  ;; (defun downcase-sentence ()
  ;;   (interactive)
  ;; (unless (my/beginning-of-sentence-p)
  ;; (org-backward-sentence))
  ;;   (downcase-word 1)
  ;; (org-forward-sentence 1)
  ;; (jay/right-char)
  ;; )

  ;; (define-key key-minor-mode-map (kbd "M-L") 'downcase-sentence)

#+END_SRC
* return-insert-blank-line-before

#+BEGIN_SRC emacs-lisp
(defun return-insert-blank-line-before ()
  (interactive)
  (beginning-of-line)
(newline)
  )
#+END_SRC

* toggle item or hyphenation
#+BEGIN_SRC emacs-lisp
(defun toggle-item-or-hyphenation ()
(interactive "P")
(if

    (region-active-p)                               ; if
    (org-toggle-item) ; then
    (cycle-hyphenation); else
)
)
#+END_SRC

* my-forward-sentence...???
#+BEGIN_SRC emacs-lisp
(defun smart-forward-sentence ()
  (interactive)
  (org-forward-sentence)
  (my/fix-space)
  )
#+END_SRC
* replace-inner...???
#+BEGIN_SRC emacs-lisp
(defun replace-inner ()
  (interactive)
(change-inner)
  (pasteboard-paste-no-spaces)
  )
#+END_SRC

doesn't work.
* embolden-or-bold

#+BEGIN_SRC emacs-lisp

(defun embolden-or-bold (arg)
  (interactive "p")
  (if (region-active-p)
      ;;      (wrap-region-trigger arg "*")
      (let ((s (replace-regexp-in-string
                "[*]" "" (delete-and-extract-region (region-beginning) (region-end)))))
        (insert "*")
        (insert s)
        (insert "*"))
    (embolden-next-word)))

#+END_SRC

* save buffer to sent-emails-org-file
#+BEGIN_SRC emacs-lisp
(defvar *sent-emails-org-file* "~/Documents/random/sent-emails.org")

(defun save-buffer-to-sent-emails-org-file ()
  ;; header

(write-region
   (concat "\n\n\n* "
(format-time-string "%F %l:%M%P\n\n")
           "\n\n")
   0 *sent-emails-org-file* t)
  ;; buffer
  (write-region nil 0 *sent-emails-org-file* t))
#+END_SRC
* send message without bullets
#+BEGIN_SRC emacs-lisp
(defun send-message-without-bullets ()
  (interactive)
  (remove-hook 'org-mode-hook 'org-bullets-mode)
;; (notmuch-mua-send-and-exit)
(message-send-and-exit) 
  (add-hook 'org-mode-hook 'org-bullets-mode))

(add-hook 'message-mode-hook
          (lambda ()
            (local-set-key "\C-c\C-c" 'send-message-without-bullets)
            (local-set-key "\C-c\C-l" 'org-insert-link)
))

#+END_SRC
* sign current email
#+BEGIN_SRC emacs-lisp
(defvar *mail-signature* "\n---\nRichard Trotta\nPhD Candidate, Nuclear Physics\nThe Catholic University of America\n(646) 355-8001")

(defun sign-current-email ()
  (save-excursion
    (end-of-buffer)
    (insert *mail-signature*)))
#+END_SRC

* custom-send-message
#+BEGIN_SRC emacs-lisp
(defun custom-send-message (arg)
  (interactive "p")
  (when (and arg (= 0 (mod arg 4)))
    (sign-current-email))
  (save-buffer-to-sent-emails-org-file)
  (send-message-without-bullets))
#+END_SRC
* reformat email
#+BEGIN_SRC emacs-lisp
(defun reformat-email (begin end)
  (interactive "r")
(xah-replace-pairs-region begin end
 '(
 ["> " ""]
))
  (unfill-region begin end)
  (fill-region begin end)
  (xah-replace-pairs-region begin end
 '(
 ["\n" "\n> "]
)))

#+END_SRC
* fix image links
#+BEGIN_SRC emacs-lisp
(defun fix-image-links ()
(interactive)
(goto-char 1)
(while (search-forward-regexp "[[\(.*?\).jpg][\(.*?\).jpg]]" nil t)
  (replace-match "[[" (match-string 1) ".jpg]]"  t nil))

(while (search-forward-regexp "[[\(.*?\).png][\(.*?\).png]]" nil t)
  (replace-match "[[" (match-string 1) ".png]]"  t nil))
)
#+END_SRC

* replace garbage characters

Òembedding-

→

"embedding"

#+BEGIN_SRC emacs-lisp
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun replace-garbage-chars ()
"Replace goofy MS and other garbage characters with latin1 equivalents."
(interactive)
(save-excursion				;save the current point
  (replace-string "  " " " nil (point-min) (point-max))
  (replace-string "" "" nil (point-min) (point-max))
  (replace-string "΄" "\"" nil (point-min) (point-max))
  (replace-string "“" "\"" nil (point-min) (point-max))
  (replace-string "’" "'" nil (point-min) (point-max))
  (replace-string "“" "\"" nil (point-min) (point-max))
  (replace-string "—" "--" nil (point-min) (point-max)) ; multi-byte
  (replace-string "" "'" nil (point-min) (point-max))
  (replace-string "" "'" nil (point-min) (point-max))
  (replace-string "" "\"" nil (point-min) (point-max))
  (replace-string "" "\"" nil (point-min) (point-max))
  (replace-string "" "\"" nil (point-min) (point-max))
  (replace-string "" "\"" nil (point-min) (point-max))
  (replace-string "‘" "\"" nil (point-min) (point-max))
  (replace-string "’" "'" nil (point-min) (point-max))
  (replace-string "¡\"" "\"" nil (point-min) (point-max))
  (replace-string "¡­" "..." nil (point-min) (point-max))
  (replace-string "" "..." nil (point-min) (point-max))
  (replace-string "" " " nil (point-min) (point-max)) ; M-SPC
  (replace-string "" "`" nil (point-min) (point-max))  ; \221
  (replace-string "" "'" nil (point-min) (point-max))  ; \222
  (replace-string "" "``" nil (point-min) (point-max))
  (replace-string "" "''" nil (point-min) (point-max))
  (replace-string "" "*" nil (point-min) (point-max))
  (replace-string "" "--" nil (point-min) (point-max))
  (replace-string "" "--" nil (point-min) (point-max))
  (replace-string " " " " nil (point-min) (point-max)) ; M-SPC
  (replace-string "¡" "\"" nil (point-min) (point-max))
  (replace-string "´" "\"" nil (point-min) (point-max))
  (replace-string "»" "<<" nil (point-min) (point-max))
  (replace-string "Ç" "'" nil (point-min) (point-max))
  (replace-string "È" "\"" nil (point-min) (point-max))
  (replace-string "é" "e" nil (point-min) (point-max)) ;; &eacute;
  (replace-string "ó" "-" nil (point-min) (point-max))

  (replace-string " Ñ " "---" nil (point-min) (point-max))


  (replace-string "á" "-" nil (point-min) (point-max))
(replace-string "     " "" nil (point-min) (point-max))
(replace-string "    " "" nil (point-min) (point-max))
(replace-string " " " " nil (point-min) (point-max))
(replace-string " " "" nil (point-min) (point-max))


(replace-string "Õ" "'" nil (point-min) (point-max))
(replace-string "Ò" "\"" nil (point-min) (point-max))
(replace-string "Ó" "\"" nil (point-min) (point-max))



))
#+END_SRC

* flyspell fix...???
#+BEGIN_SRC emacs-lisp
(setq flyspell-abbrev-p t)
(setq flyspell-use-global-abbrev-table-p t)
(setq global-flyspell-mode t)
#+END_SRC

* mw-thesaurus...ERROR
#+BEGIN_SRC emacs-lisp
  ;; (require 'mw-thesaurus)
  ;; (load "~/.emacs.d/lisp-files/secret-codes.el")
  ;; (define-key key-minor-mode-map (kbd "M-s-t") 'mw-thesaurus--lookup-at-point)
#+END_SRC

* web-mode...ERROR
#+BEGIN_SRC emacs-lisp

  ;;     (use-package web-mode

  ;; :init
  ;;  (add-hook 'web-mode-hook
  ;;       (lambda ()
  ;;        (rainbow-mode)
  ;;        (rspec-mode)
  ;;        (setq web-mode-markup-indent-offset 2)))

  ;; ;; (setq web-mode-load-hook (quote ((lambda nil (abbrev-mode -1)))))

  ;; (add-hook 'web-mode-hook (lambda () (abbrev-mode -1)))

  ;;     :bind (:map web-mode-map 


  ;;   ("s-O" . prelude-open-with)))
#+END_SRC
* gnus
#+BEGIN_SRC emacs-lisp
(setq user-mail-address "trotta@cua.edu")
(setq user-full-name "Richard Trotta")
(setq gnus-always-read-dribble-file t)
(setq gnus-select-method '(nnml ""))
(setq gnus-select-method '(nnimap "gmail"
(nnimap-address "imap.gmail.com")
(nnimap-server-port 993)
(nnimap-stream ssl)))
(setq gnus-use-cache t) 




(setq gnus-select-method
   '(nnimap "gmail"
	    (nnimap-address "imap.gmail.com") ; it could also be imap.googlemail.com if that's your server.
	    (nnimap-server-port "imaps")
	    (nnimap-stream ssl)))




;; store email in ~/gmail directory
(setq nnml-directory "~/gmail")
;; (setq message-directory "~/gmail") 

;; define gnus directories
;; (setq message-directory "~/emacs/gnus/mail/")
(setq gnus-directory "~/emacs/gnus/news/")
(setq nnfolder-directory "~/emacs/gnus/mail/archive") 

;; How to read HTML mail
(setq mm-text-html-renderer 'w3m)
(setq gnus-summary-line-format "%-6,6B%-15,15f |%* %-40,40s | %&user-date; | %U\n")

;; sort by most recent date
(setq gnus-article-sort-functions (quote ((not gnus-article-sort-by-date))))
(setq gnus-thread-sort-functions (quote ((not gnus-thread-sort-by-date))))


;; More attractive Summary View
;; http://groups.google.com/group/gnu.emacs.gnus/browse_thread/thread/a673a74356e7141f
(when window-system
 (setq gnus-sum-thread-tree-indent " ")
 (setq gnus-sum-thread-tree-root "") ;; "● ")
 (setq gnus-sum-thread-tree-false-root "") ;; "◯ ")
 (setq gnus-sum-thread-tree-single-indent "") ;; "◎ ")
 (setq gnus-sum-thread-tree-vertical    "│")
 (setq gnus-sum-thread-tree-leaf-with-other "├─► ")
 (setq gnus-sum-thread-tree-single-leaf   "╰─► "))
(setq gnus-summary-line-format
   (concat
    "%0{%U%R%z%}"
    "%3{│%}" "%1{%d%}" "%3{│%}" ;; date
    " "
    "%4{%-20,20f%}"        ;; name
    " "
    "%3{│%}"
    " "
    "%1{%B%}"
    "%s\n"))
(setq gnus-summary-display-arrow t)
#+END_SRC
* modified email-heading function

#+BEGIN_SRC emacs-lisp

  (defun org-mime-htmlize (&optional arg)
  "Export a portion of an email body composed using `mml-mode' to
  html using `org-mode'. If called with an active region only
  export that region, otherwise export the entire body."
   (interactive "P")
   (require 'ox-org)
   (require 'ox-html)
   (let* ((region-p (org-region-active-p))
       (html-start (or (and region-p (region-beginning))
	       (save-excursion
		(goto-char (point-min))
		(search-forward mail-header-separator)
		(+ (point) 1))))
       (html-end (or (and region-p (region-end))
	      ;; TODO: should catch signature...
	      (point-max)))
       (raw-body (concat org-mime-default-header
			    (buffer-substring html-start html-end)))
       (tmp-file (make-temp-name (expand-file-name
				    "mail" temporary-file-directory)))
       (body (org-export-string-as raw-body 'org t))
       ;; because we probably don't want to export a huge style file
       (org-export-htmlize-output-type 'inline-css)
       ;; makes the replies with ">"s look nicer
       (org-export-preserve-breaks org-mime-preserve-breaks)
       ;; dvipng for inline latex because MathJax doesn't work in mail
       (org-html-with-latex 'dvipng)
       ;; to hold attachments for inline html images
       (html-and-images
	(org-mime-replace-images
	 (org-export-string-as raw-body 'html t) tmp-file))
       (html-images (unless arg (cdr html-and-images)))
       (html (org-mime-apply-html-hook
	      (if arg
		  (format org-mime-fixedwith-wrap body)
		(car html-and-images)))))
     (delete-region html-start html-end)
     (save-excursion
       (goto-char html-start)
       (insert (org-mime-multipart
		body html (mapconcat 'identity html-images "\n"))))))
#+END_SRC
* new-email-from-subtree-with-signature 

#+BEGIN_SRC emacs-lisp 

(defun new-email-from-subtree-with-signature ()
 "Send the current org-mode heading as the body of an email, with headline as the subject.

use these properties
TO
CC
BCC
OTHER-HEADERS is an alist specifying additional
header fields. Elements look like (HEADER . VALUE) where both
HEADER and VALUE are strings.

Save when it was sent as a SENT property. this is overwritten on
subsequent sends."
 (interactive)
 ; store location.
 (setq *email-heading-point* (set-marker (make-marker) (point)))
 (save-excursion
  (let ((content (progn
           (unless (org-on-heading-p) (outline-previous-heading))
           (let ((headline (org-element-at-point)))
            (buffer-substring
            (org-element-property :contents-begin headline)
            (org-element-property :contents-end headline)))))
     (TO (org-entry-get (point) "TO" t))
     (CC (org-entry-get (point) "CC" t))
     (BCC (org-entry-get (point) "BCC" t))
     (SUBJECT (nth 4 (org-heading-components)))
     (OTHER-HEADERS (eval (org-entry-get (point) "OTHER-HEADERS")))
     (continue nil)
     (switch-function nil)
     (yank-action nil)
     (send-actions '((email-send-action . nil)))
     (return-action '(email-heading-return)))

   (compose-mail TO SUBJECT OTHER-HEADERS continue switch-function yank-action send-actions return-action)
   (message-goto-body)
   (insert content)
   (when CC
    (message-goto-cc)
    (insert CC))
   (when BCC
    (message-goto-bcc)
    (insert BCC))
   (if TO
     (message-goto-body)
    (message-goto-to))
(end-of-buffer)
(insert "\Best regards,\Richard Trotta\n\n---\nRichard Trotta
(610) 739-0709
[[trotta@cua.edu]]
\n")
(message-goto-to))
))


(defun new-email-from-subtree-no-signature ()
 "Send the current org-mode heading as the body of an email, with headline as the subject.

use these properties
TO
CC
BCC
OTHER-HEADERS is an alist specifying additional
header fields. Elements look like (HEADER . VALUE) where both
HEADER and VALUE are strings.

Save when it was sent as a SENT property. this is overwritten on
subsequent sends."
 (interactive)
 ; store location.
 (setq *email-heading-point* (set-marker (make-marker) (point)))
 (save-excursion
  (let ((content (progn
           (unless (org-on-heading-p) (outline-previous-heading))
           (let ((headline (org-element-at-point)))
            (buffer-substring
            (org-element-property :contents-begin headline)
            (org-element-property :contents-end headline)))))
     (TO (org-entry-get (point) "TO" t))
     (CC (org-entry-get (point) "CC" t))
     (BCC (org-entry-get (point) "BCC" t))
     (SUBJECT (nth 4 (org-heading-components)))
     (OTHER-HEADERS (eval (org-entry-get (point) "OTHER-HEADERS")))
     (continue nil)
     (switch-function nil)
     (yank-action nil)
     (send-actions '((email-send-action . nil)))
     (return-action '(email-heading-return)))

   (compose-mail TO SUBJECT OTHER-HEADERS continue switch-function yank-action send-actions return-action)
   (message-goto-body)
   (insert content)
   (when CC
    (message-goto-cc)
    (insert CC))
   (when BCC
    (message-goto-bcc)
    (insert BCC))
   (if TO
     (message-goto-body)
    (message-goto-to))
;; (end-of-buffer)
)
))
#+END_SRC
* Remove footer in html conversion
#+BEGIN_SRC emacs-lisp 
(setq org-html-validation-link nil)
(setq org-export-html-postamble nil)
#+END_SRC
* markdown
#+BEGIN_SRC emacs-lisp 
(require 'package)
(add-to-list 'package-archives
             '("melpa-stable" . "https://stable.melpa.org/packages/"))
(package-initialize)
#+END_SRC
* alias
#+BEGIN_SRC emacs-lisp 
(load-file "~/.emacs.d/alias.el")
#+END_SRC

* fixes melpa archive download error
#+begin_SRC emacs-lisp 
(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")
#+end_SRC
* fix latex to pdf conversion
#+begin_SRC emacs-lisp 
(load-file "~/.emacs.d/elpa/org-9.5.4/ox-latex.el")
#+end_SRC
